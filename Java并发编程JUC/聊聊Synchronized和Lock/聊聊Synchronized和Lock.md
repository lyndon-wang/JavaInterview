# 聊聊Synchronized和Lock

## 相关链接：

[Java锁与线程的那些事](https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/)

# 1.Synchronized

参考：[synchronized原理及其应用](https://juejin.cn/post/6844904114061590535#heading-5)

## 1.1-对象头

在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。

<img src="%E8%81%8A%E8%81%8ASynchronized%E5%92%8CLock.images/image-20220126151007485.png" alt="image-20220126151007485" style="zoom:80%;" />

- 对象头

  - **Mark Word（标记字段）**：默认存储对象的HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。
  - **Klass Point（类型指针）**：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

- 实例数据

  - 这部分主要是存放类的数据信息，父类的信息。

- 对其填充

  - 由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。

    Tip：不知道大家有没有被问过一个空对象占多少个字节？就是8个字节，是因为对齐填充的关系哈，不到8个字节对其填充会帮我们自动补齐。

运行期间，Mark Word里存储的数据随锁标志位的变化而变化，可能存在如下4种数据。

![image-20220126151804800](%E8%81%8A%E8%81%8ASynchronized%E5%92%8CLock.images/image-20220126151804800.png)

## 1.2-底层实现

### 1.2.1-Monitor 机制

monitor 的重要特点是，同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区，这使得 monitor 能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入 monitor 临界区的 进程/线程，它们应该被阻塞，并且在必要的时候会被唤醒。显然，monitor 作为一个同步工具，也应该提供这样的管理 进程/线程 状态的机制。想想我们为什么觉得 semaphore 和 mutex 在编程上容易出错，因为我们需要去亲自操作变量以及对 进程/线程 进行阻塞和唤醒。monitor 这个机制之所以被称为“更高级的原语”，那么它就不可避免地需要对外屏蔽掉这些机制，并且在内部实现这些机制，使得使用 monitor 的人看到的是一个简洁易用的接口。

### 1.2.2-monitor 基本元素

1. 临界区
2. monitor 对象及锁
3. 条件变量以及定义在 monitor 对象上的 wait，signal 操作。

使用 monitor 机制的目的主要是为了互斥进入临界区，为了做到能够阻塞无法进入临界区的 进程/线程，还需要一个 monitor object 来协助，这个 monitor object 内部会有相应的数据结构，例如列表，来保存被阻塞的线程；同时由于 monitor 机制本质上是基于 mutex 这种基本原语的，所以 monitor object 还必须维护一个基于 mutex 的锁。 此外，为了在适当的时候能够阻塞和唤醒 进程/线程，还需要引入一个条件变量，这个条件变量用来决定什么时候是“适当的时候”，这个条件可以来自程序代码的逻辑，也可以是在monitor object 的内部，总而言之，程序员对条件变量的定义有很大的自主性。不过，由于 monitor object 内部采用了数据结构来保存被阻塞的队列，因此它也必须对外提供两个 API 来让线程进入阻塞状态以及之后被唤醒，分别是 wait 和 notify。

### 1.2.3-临界区的圈定

正常去使用Synchronized一般都是用在下面这几种场景：

[synchronized 加锁 this 和 class 的区别！](https://juejin.cn/post/6991428725980037151#heading-8)

- 修饰实例方法，当 synchronized 修饰普通方法时，被修饰的方法被称为同步方法，其作用范围是整个方法，作用的对象是调用这个方法的对象。

  ```java
  public class Synchronized {
      public synchronized void husband(){
  
      }
  }
  ```

- 修饰静态方法，对当前类的Class对象加锁，其作用的范围是整个方法，作用对象是调用这个类的所有对象。

  ```java
  /**
   * synchronized 修饰静态方法
   */
  public static synchronized void staticMethod() {
      // .......
  }
  
  ```

- [synchronized关键字修饰代码块](https://blog.csdn.net/liuxiao723846/article/details/108777829)

在java中，被 synchronized 关键字修饰的方法、代码块，就是 monitor 机制的临界区。

### 1.2.4-monitor object

synchronzied 在使用时需要关联一个对象，而这个对象就是 monitor object。 monitor 的机制中，*monitor  object* 充当着维护 mutex以及定义 wait/signal API 来管理线程的阻塞和唤醒的角色。 Java 语言中的 *java.lang.Objec*t 类，便是满足这个要求的对象，任何一个 Java 对象都可以作为 monitor 机制的 *monitor object*。
 Java 对象存储在内存中，分别分为三个部分，即对象头、实例数据和对齐填充，而在其对象头中，保存了锁标识；同时，java.lang.Object 类定义了 wait()，notify()，notifyAll() 方法，这些方法的具体实现，依赖于一个叫 ObjectMonitor 模式的实现，这是 JVM 内部基于 C++ 实现的一套机制，基本原理如下所示：

![image-20220126161941946](%E8%81%8A%E8%81%8ASynchronized%E5%92%8CLock.images/image-20220126161941946.png)

当一个线程需要获取 Object 的锁时，会被放入 EntrySet 中进行等待，如果该线程获取到了锁，成为当前锁的 owner。如果根据程序逻辑，一个已经获得了锁的线程缺少某些外部条件，而无法继续进行下去（例如生产者发现队列已满或者消费者发现队列为空），那么该线程可以通过调用 wait 方法将锁释放，进入 wait set 中阻塞进行等待，其它线程在这个时候有机会获得锁，去干其它的事情，从而使得之前不成立的外部条件成立，这样先前被阻塞的线程就可以重新进入 EntrySet                去竞争锁。这个外部条件在 monitor 机制中称为条件变量。

### 1.2.5-实现过程

1. 当我们进入一个方法的时候，执行**monitorenter**，就会获取当前对象的一个所有权，这个时候monitor进入数为1，当前的这个线程就是这个monitor的owner。
2. 如果你已经是这个monitor的owner了，你再次进入，就会把进入数+1.
3. 同理，当他执行完**monitorexit**，对应的进入数就-1，直到为0，才可以被其他线程持有。

### 1.2.6-总结

`synchronized` **同步语句块**的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**

## 1.3-锁的升级过程

synchronized 在开始的时候是依靠操作系统的互斥锁来实现的，是个重量级操作，为了减少获得锁和释放锁带来的性能消耗，在 JDK 1.6中，引入了偏向锁和轻量级锁。锁一共有4中状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几种状态会随着竞争情况逐渐升级，但不能降级，目的是为了提高锁和释放锁的效率。

![image-20220227142938482](%E8%81%8A%E8%81%8ASynchronized%E5%92%8CLock.images/image-20220227142938482.png)

### 1.3.1-偏向锁

[偏向锁详细说明（jdk15开始默认不开启）](https://juejin.cn/post/7046921350065160206#heading-5)

大部分情况下，锁不存在多线程竞争，偏向锁就是为了在只有一个线程执行同步块时提高性能。

偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。

**获得过程：**

1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为 01——确认为可偏向状态。
2. 如果为可偏向状态，则测试 Thread ID 是否指向当前线程，如果是，执行同步代码。
3. 如果不是指向当前线程，使用 CAS 竞争锁，如果竞争成功，则将 Mark Word 中 Thread ID 设置为当前线程ID，并在栈帧中锁记录（Lock Record）里存储当前线程ID。
4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint，在这个时间点上没有正在执行的字节码）时，会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着（**因为可能持有偏向锁的线程已经执行完毕，但是该线程并不会主动去释放偏向锁**）。
5. 如果线程不处于活动状态，则将对象头设置成无锁状态（标志位为“01”），然后重新偏向新的线程；如果线程仍然活着，撤销偏向锁后升级到轻量级锁状态（标志位为“00”），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。

**锁释放过程：**

其实就是上面锁获得过程的四五步。

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

偏向锁的撤销，需要等待全局安全点（这个时间点没有正在执行的字节码）。

1. 到全局安全点后，先暂停拥有偏向锁的线程，检查该线程是否或者。
2. 不活动或已经退出代码块，则对象头设置为无锁状态，然后重新偏向新的线程。
3. 如果仍然活着，则遍历线程栈中所有的 Lock Record，如果能找到对应的 Lock Record 说明偏向的线程还在执行同步代码块中的代码。需要升级为轻量级锁，直接修改偏向线程栈中的Lock Record。
4. 此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。

![image-20220126170957631](%E8%81%8A%E8%81%8ASynchronized%E5%92%8CLock.images/image-20220126170957631.png)

### 1.3.2-轻量级锁

**锁获得过程：**

1. 如果锁对象不是偏向模式或已经偏向其他线程，这时候会构建一个无锁状态的`mark word`设置到`Lock Record`中去，我们称`Lock Record`中存储对象`mark word`的字段叫 Displaced Mark Word。
2. 拷贝对象头中的Mark Word复制到锁记录中。然后虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。
3. 如果更新成功，当前线程获得锁，执行同步代码。如果更新失败，当前线程便尝试使用自旋来获取锁。
4. 当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞。

**锁释放过程：**

1. 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。
2. 如果替换成功，整个同步过程就完成了。
3. 如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。

![image-20220126192041646](%E8%81%8A%E8%81%8ASynchronized%E5%92%8CLock.images/image-20220126192041646.png)

### 1.3.3-重量级锁

重量级锁的上锁过程参考上面步骤 4 ，轻量级锁膨胀为重量级锁，Mark Word的锁标记位更新为10，Mark Word 指向互斥量（重量级锁）。

Synchronized 的重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的，文章开头有讲解。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。

### 1.3.4-对象锁和类锁的理解

[synchronized的对象锁和类锁的区别](https://juejin.cn/post/6901885210938310670)

**对象锁：**

Java 中每个对象都有一个锁，并且是唯一的。假设分配的一个对象空间，里面有多个方法，相当于空间里面有多个小房间，如果我们把所有的小房间都加锁，因为这个对象只有一把钥匙，因此同一时间只能有一个人打开一个小房间，然后用完了还回去，再由 JVM 去分配下一个获得钥匙的人。**所以两个线程同时访问一个对象的两个普通同步方法是串行执行的**

**类锁：**

类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，一把钥匙。

## 1.4-锁优化

### 1.4.1- 锁消除

锁消除即删除不必要的加锁操作。虚拟机即时编辑器在运行时，对一些“代码上要求同步，但是被检测到不可能存在共享数据竞争”的锁进行消除。

### 1.4.2-锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

### 1.4.3-自旋锁与自适应自旋锁

**引入自旋锁的原因：**

互斥同步对性能最大的影响是阻塞的实现，因为挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来很大的压力。同时虚拟机的开发团队也注意到在许多应用上面，共享数据的锁定状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。

**自旋锁：**

让该线程执行一段无意义的忙循环（自旋）等待一段时间，不会被立即挂起（自旋不放弃处理器额执行时间），看持有锁的线程是否会很快释放锁。自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用 -XX:+UseSpinning 开启；在JDK1.6中默认开启。

**自旋锁的缺点：**

自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好；反之，自旋的线程就会白白消耗掉处理器的资源，它不会做任何有意义的工作，这样反而会带来性能上的浪费。

**自适应的自旋锁：**

JDK1.6 引入自适应的自旋锁，自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：如果在同一个锁的对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。简单来说，就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。

## 1.5-小结

**synchronized特点：** 保证内存可见性、操作原子性。在经过jdk6的优化，synchronized 的性能其实不必 JVM 实现的 Reentrantlock 差，甚至有的时候比它更优秀，这也是 Java concurrent 包下很多类的原理都是基于 synchronized 实现的原因。


# 面试题

### Q:什么是进程，什么是线程

>进程就是**应用程序在内存中分配的空间，也就是正在运行的程序**，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。
>
>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。（javaguide）
>
>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
>
>ps:Java 程序天生就是多线程程序——**一个 Java 程序的运行是 main 线程和多个其他线程同时运行**。

### Q:**多进程的方式也可以实现并发，为什么我们要使用多线程？**

>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：
>
>- 进程间的通信比较复杂，而线程间的**通信比较简单**，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。
>- 进程是重量级的，而线程是**轻量级**的，故多线程方式的**系统开销更小**。

### Q:**进程和线程有什么区别**

>**进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。**
>
>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是**是否单独占有内存地址空间及其它系统资源（比如I/O）**：
>
>- 进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。
>- 一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。
>- 进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。
>
>另外一个重要区别是，**进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位**，即CPU分配时间的单位 。

### 扩展：程序计数器为什么是私有的?

>程序计数器主要有下面两个作用：
>
>1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
>2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
>
>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。[Java线程执行native方法时程序计数器为空，如何确保native执行完后的程序执行的位置](https://blog.csdn.net/weixin_41884010/article/details/103593628)
>
>所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

### 扩展：虚拟机栈和本地方法栈为什么是私有的?

>- **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
>- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
>
>所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

### Q:为什么要使用多线程呢?

>先从总体上来说：
>
>- **从计算机底层来说：** 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
>- **从当代互联网发展趋势来说：** 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。
>
>再深入到计算机底层来探讨：
>
>- **单核时代**： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。
>- **多核时代**: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。

### Q:说说线程的生命周期和状态?

>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态:

<img src="https://gitee.com/master_p/ImageHost/raw/master/Typora/2022/4/202205031401340.png" alt="image-20220503140107961" style="zoom:120%;" />

> Java 线程状态变迁如下图所示:

![image-20220503141915830](https://gitee.com/master_p/ImageHost/raw/master/Typora/2022/4/202205031419910.png)

### Q:为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？

>[为什么start方法会调用run方法?(为什么不能直接run来实现创建线程？）](https://blog.csdn.net/qq_42859864/article/details/103428493)
>
>new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。
>
>**总结： 调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行,其方法还是运行在主线程中，代码在程序中是顺序执行的。**

### Q:反复调用同一个线程的start()方法是否可行？假如一个线程执行完毕(此时处于TERMINATED状态),再次调用这个线程的start()方法是否可行？

>不可行，在调用一次start()之后，threadStatus的值会改变（threadStatus !=0），此时再次调用start()方法会抛出IllegalThreadStateException异常。
>
>比如，threadStatus为2代表当前线程状态为TERMINATED。
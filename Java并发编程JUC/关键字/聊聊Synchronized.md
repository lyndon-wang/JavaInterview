# 聊聊Synchronized

## 相关链接：

[Java锁与线程的那些事](https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/)

## 带着BAT大厂的面试问题去理解Synchronized

- Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。

- Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。

- Synchronized由什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。

- Synchronized和Lock的对比，和选择?

- Synchronized在使用时有何注意事项?

- Synchronized修饰的方法在抛出异常时,会释放锁吗?

- 多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?

  > 这个问题就涉及到内部锁的调度机制，线程获取 synchronized 对应的锁，也是有具体的调度算法的，这个和具体的虚拟机版本和实现都有关系，所以下一个获取锁的线程是事先没办法预测的。

- Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?

  > - 优化 synchronized 的使用范围，让临界区的代码在符合要求的情况下尽可能的小。
  > - 使用其他类型的 lock（锁），synchronized 使用的锁经过 jdk 版本的升级，性能已经大幅提升了，但相对于更加轻量级的锁（如读写锁）还是偏重一点，所以可以选择更合适的锁。

- 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?

  > 可以根据需要实现一个 Lock 接口，这样锁的获取和释放就能完全被我们控制了。

- 什么是锁的升级和降级? 什么是JVM里的偏向锁、轻量级锁、重量级锁?

- 不同的JDK中对Synchronized有何优化?

## Synchronized的使用

在应用Sychronized关键字时需要把握如下注意点：

- 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；
- 每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁
- synchronized修饰的方法，**无论方法正常执行完毕还是抛出异常**，都会释放锁

参考：[synchronized原理及其应用](https://juejin.cn/post/6844904114061590535#heading-5)

## 1.1-对象头

在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。

![image-20220726132834806](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207261328957.png)

- 对象头

  - **Mark Word（标记字段）**：默认存储对象的HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。
  - **class Point（类型指针）**：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

- 实例数据

  - 这部分主要是存放类的数据信息，父类的信息。

- 对其填充

  - 由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。

    Tip：不知道大家有没有被问过一个空对象占多少个字节？就是8个字节，是因为对齐填充的关系哈，不到8个字节对其填充会帮我们自动补齐。

运行期间，Mark Word里存储的数据随锁标志位的变化而变化，可能存在如下4种数据。

![image-20220726133748219](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207261337316.png)

## 1.2-底层实现

### 1.2.1-Monitor 机制

monitor 的重要特点是，**同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区**，这使得 monitor 能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入 monitor 临界区的 进程/线程，它们应该被阻塞，并且在必要的时候会被唤醒。显然，monitor 作为一个同步工具，也应该提供这样的管理 进程/线程 状态的机制。monitor 这个机制之所以被称为“更高级的原语”，那么它就不可避免地需要对外屏蔽掉这些机制，并且在内部实现这些机制，使得使用 monitor 的人看到的是一个简洁易用的接口。

### 1.2.2-monitor 基本元素

1. 临界区
2. monitor 对象及锁
3. 条件变量以及定义在 monitor 对象上的 wait，signal 操作。

使用 monitor 机制的目的主要是为了互斥进入临界区，为了做到能够阻塞无法进入临界区的 进程/线程，还需要一个 monitor object 来协助，这个 monitor object 内部会有相应的数据结构，例如列表，来保存被阻塞的线程；同时由于 monitor 机制本质上是**基于 mutex 这种基本原语的**，所以 monitor object 还必须维护一个基于 mutex 的锁。 此外，为了在适当的时候能够阻塞和唤醒 进程/线程，还需要引入一个条件变量，这个条件变量用来决定什么时候是“适当的时候”，这个条件可以来自程序代码的逻辑，也可以是在monitor object 的内部，总而言之，程序员对条件变量的定义有**很大的自主性**。不过，由于 monitor object 内部采用了数据结构来保存被阻塞的队列，因此它也必须对外提供两个 API 来让线程进入阻塞状态以及之后被唤醒，分别是 wait 和 notify。

### 1.2.3-临界区的圈定

正常去使用Synchronized一般都是用在下面这几种场景：

[synchronized 加锁 this 和 class 的区别！](https://juejin.cn/post/6991428725980037151#heading-8)：当**使用 synchronized 加锁 class 时，无论共享一个对象还是创建多个对象，它们用的都是同一把锁**，而**使用 synchronized 加锁 this 时，只有同一个对象会使用同一把锁，不同对象之间的锁是不同的**。

- 修饰实例方法，当 synchronized 修饰普通方法时，被修饰的方法被称为同步方法，其作用范围是整个方法，作用的对象是调用这个方法的对象。

  ```java
  public class Synchronized {
      public synchronized void husband(){
  
      }
  }
  ```

- 修饰静态方法，对当前类的Class对象加锁，其作用的范围是整个方法，作用对象是调用这个类的所有对象。

  ```java
  /**
   * synchronized 修饰静态方法
   */
  public static synchronized void staticMethod() {
      // .......
  }
  
  ```

- [synchronized关键字修饰代码块](https://blog.csdn.net/liuxiao723846/article/details/108777829)

在java中，被 synchronized 关键字修饰的方法、代码块，就是 monitor 机制的临界区。

### 1.2.4-monitor object

synchronzied 在使用时需要关联一个对象，而这个对象就是 monitor object。 monitor 的机制中，*monitor  object* 充当着维护 mutex以及定义 wait/signal API 来管理线程的阻塞和唤醒的角色。 Java 语言中的 *java.lang.Objec*t 类，便是满足这个要求的对象，任何一个 Java 对象都可以作为 monitor 机制的 *monitor object*。
 Java 对象存储在内存中，分别分为三个部分，即对象头、实例数据和对齐填充，而在其对象头中，保存了锁标识；同时，java.lang.Object 类定义了 wait()，notify()，notifyAll() 方法，这些方法的具体实现，依赖于一个叫 ObjectMonitor 模式的实现，这是 JVM 内部基于 C++ 实现的一套机制，基本原理如下所示：

![image-20220726141659754](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207261416832.png)

当一个线程需要获取 Object 的锁时，会被放入 EntrySet 中进行等待，如果该线程获取到了锁，成为当前锁的 owner。如果根据程序逻辑，一个已经获得了锁的线程缺少某些外部条件，而无法继续进行下去（例如生产者发现队列已满或者消费者发现队列为空），那么该线程可以通过调用 wait 方法将锁释放，进入 wait set 中阻塞进行等待，其它线程在这个时候有机会获得锁，去干其它的事情，从而使得之前不成立的外部条件成立，这样先前被阻塞的线程就可以重新进入 EntrySet去竞争锁。这个外部条件在 monitor 机制中称为条件变量。

### 1.2.5-实现过程

1. 当我们进入一个方法的时候，执行**monitorenter**，就会获取当前对象的一个所有权，这个时候monitor进入数为1，当前的这个线程就是这个monitor的owner。
2. 如果你已经是这个monitor的owner了，你再次进入，就会把进入数+1.
3. 同理，当他执行完**monitorexit**，对应的进入数就-1，直到为0，才可以被其他线程持有。

 **可重入锁**：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞，这就是`Synchronized`的**重入性**。

### 1.2.6-保证可见性的原理：内存模型和happens-before规则

`Synchronized`的`happens-before`规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。

```java
public class MonitorDemo {
    private int a = 0;

    public synchronized void writer() {     // 1
        a++;                                // 2
    }                                       // 3

    public synchronized void reader() {    // 4
        int i = a;                         // 5
    }                                      // 6
}
```

该代码的happens-before关系如图所示：

![image-20220726155304648](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207261553758.png)

在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。

**根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。**

### 1.2.7-总结

`synchronized` **同步语句块**的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**

## 1.3-锁的升级过程

![image-20220727094457529](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207270944612.png)

synchronized 在开始的时候是依靠操作系统的互斥锁来实现的，是个重量级操作，为了减少获得锁和释放锁带来的性能消耗，在 JDK 1.6中，引入了偏向锁和轻量级锁。锁一共有4中状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几种状态会随着竞争情况逐渐升级，但不能降级，目的是为了提高锁和释放锁的效率。

![image-20220726141703169](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207261417277.png)

### 1.3.1-偏向锁

**！！[偏向锁详细说明（jdk15开始默认不开启）](https://juejin.cn/post/7046921350065160206#heading-5)**

大部分情况下，锁不存在多线程竞争，偏向锁就是为了在只有一个线程执行同步块时提高性能。

偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。

**获得过程：**

1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为 01——确认为可偏向状态。
2. 如果为可偏向状态，则测试 Thread ID 是否指向当前线程，如果是，执行同步代码。
3. 如果不是指向当前线程，使用 CAS 竞争锁，如果竞争成功，则将 Mark Word 中 Thread ID 设置为当前线程ID，并在栈帧中锁记录（Lock Record）里存储当前线程ID。
4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint，在这个时间点上没有正在执行的字节码）时，会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着（**因为可能持有偏向锁的线程已经执行完毕，但是该线程并不会主动去释放偏向锁**）。
5. 如果线程不处于活动状态，则将对象头设置成无锁状态（标志位为“01”），然后重新偏向新的线程；如果线程仍然活着，撤销偏向锁后升级到轻量级锁状态（标志位为“00”），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。

**锁释放过程：**

其实就是上面锁获得过程的四五步。

偏向锁使用了一种**等到竞争出现才释放锁的机制**，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

偏向锁的撤销，需要等待全局安全点（这个时间点没有正在执行的字节码）。

1. 到全局安全点后，先暂停拥有偏向锁的线程，检查该线程是否活着。
2. 不活动或已经退出代码块，则对象头设置为无锁状态，然后重新偏向新的线程。
3. 如果仍然活着，则遍历线程栈中所有的 Lock Record，如果能找到对应的 Lock Record 说明偏向的线程还在执行同步代码块中的代码。需要升级为轻量级锁，直接修改偏向线程栈中的Lock Record。
4. 此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。

![image-20220726141707270](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207261417401.png)

### 1.3.2-轻量级锁

在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(`Lock Record`)的空间，用于存储锁对象目前的`Mark Word`的拷贝(JVM会将对象头中的`Mark Word`拷贝到锁记录中，官方称为`Displaced Mark Ward`)这个时候线程堆栈与对象头的状态如图：

![image-20220727092923384](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207270929442.png)

如上图所示：如果当前对象没有被锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录`Lock Record`的空间用于存储锁对象目前的`Mark Word`的拷贝。

 然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将`Mark Word`更新为指向`Lock Record`的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(`Mark Word`中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：

![image-20220727093039531](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207270930595.png)

 如果这个更新操作失败，JVM会检查当前的`Mark Word`中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为`10.Mark Word`中存储的时指向重量级锁的指针。

**锁获得过程：**

1. 如果锁对象不是偏向模式或已经偏向其他线程，这时候会构建一个无锁状态的`mark word`设置到`Lock Record`中去，我们称`Lock Record`中存储对象`mark word`的字段叫 `Displaced Mark Word`。

   > LockRecord用于轻量级锁优化，当解释器执行monitorenter字节码轻度锁住一个对象时，就会在获取锁的[线程](https://www.zhihu.com/search?q=线程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1359657467})的栈上显式或者隐式分配一个LockRecord.这个LockRecord存储锁对象markword的拷贝(Displaced Mark Word)，在拷贝完成后，首先会挂起持有偏向锁的线程，因为要进行尝试修改锁记录指针，MarkWord会有变化，所有线程会利用CAS尝试将MarkWord的锁记录指针改为指向自己(线程)的锁记录，然后lockrecord的owner指向对象的markword，修改成功的线程将获得轻量级锁。失败则线程升级为重量级锁。释放时会检查markword中的lockrecord指针是否指向自己(获得锁的线程lockrecord)，使用[原子](https://www.zhihu.com/search?q=原子&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1359657467})的CAS将Displaced Mark Word替换回对象头，如果成功，则表示没有竞争发生，如果替换失败则升级为[重量级锁](https://www.zhihu.com/search?q=重量级锁&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1359657467})。整个过程中，LockRecord是一个线程内独享的存储，**每一个线程都有一个可用`Monitor Record`列表。**

2. 拷贝对象头中的Mark Word复制到锁记录中。然后虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。

3. 如果更新成功，当前线程获得锁，执行同步代码。如果更新失败，当前线程便尝试使用自旋来获取锁。

4. 当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞。

**锁释放过程：**

1. 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。
2. 如果替换成功，整个同步过程就完成了。
3. 如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。

![image-20220726141713693](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207261417801.png)

### 1.3.3-重量级锁

重量级锁的上锁过程参考上面步骤 4 ，轻量级锁膨胀为重量级锁，Mark Word的锁标记位更新为10，Mark Word 指向互斥量（重量级锁）。 轻量级解锁时，会使用原子的CAS操作将`Displaced Mark Word`替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：

![image-20220727093620087](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207270936160.png)

Synchronized 的重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的，文章开头有讲解。而**操作系统实现线程之间的切换需要从用户态转换到核心态**，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。

### 1.3.4-锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                                         | 使用场景                           |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗               | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了响应速度                           | 如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能        | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不适用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 | 追求吞吐量，同步块执行速度较长     |

### 1.3.5-对象锁和类锁的理解

[synchronized的对象锁和类锁的区别](https://juejin.cn/post/6901885210938310670)

**对象锁：**

Java 中每个对象都有一个锁，并且是唯一的。假设分配的一个对象空间，里面有多个方法，相当于空间里面有多个小房间，如果我们把所有的小房间都加锁，因为这个对象只有一把钥匙，因此同一时间只能有一个人打开一个小房间，然后用完了还回去，再由 JVM 去分配下一个获得钥匙的人。**所以两个线程同时访问一个对象的两个普通同步方法是串行执行的**

**类锁：**

类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，一把钥匙。

## 1.4-锁优化

### 1.4.1- 锁消除

锁消除即删除不必要的加锁操作。虚拟机即时编辑器在运行时，对一些“代码上要求同步，但是被检测到不可能存在共享数据竞争”的锁进行消除。

### 1.4.2-锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

### 1.4.3-自旋锁与自适应自旋锁

**引入自旋锁的原因：**

互斥同步对性能最大的影响是阻塞的实现，因为挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来很大的压力。同时虚拟机的开发团队也注意到在许多应用上面，共享数据的锁定状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。

**自旋锁：**

让该线程执行一段无意义的忙循环（自旋）等待一段时间，不会被立即挂起（自旋不放弃处理器额执行时间），看持有锁的线程是否会很快释放锁。自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用 -XX:+UseSpinning 开启；在JDK1.6中默认开启。

**自旋锁的缺点：**

自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好；反之，自旋的线程就会白白消耗掉处理器的资源，它不会做任何有意义的工作，这样反而会带来性能上的浪费。

**自适应的自旋锁：**

JDK1.6 引入自适应的自旋锁，自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：如果在同一个锁的对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。简单来说，就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。

## 1.5-小结

**synchronized特点：** 保证内存可见性、操作原子性。在经过jdk6的优化，synchronized 的性能其实不比 JDK 实现的 Reentrantlock 差，甚至有的时候比它更优秀，这也是 Java concurrent 包下很多类的原理都是基于 synchronized 实现的原因。

## ps:一些缺点

1. 使用synchronized加锁的代码块或者方法，在线程获取锁时，会一直试图获取直到获取成功，不能中断。
2. 加锁的条件只能在一个锁对象上，不支持其他条件
3. 无法知道锁对象的状态，是否被锁
4. synchronized锁只支持非公平锁，无法做到公平
5. 对于读操作和写操作都是使用独占锁，无法支持共享锁（在读操作时共享，写操作时独占）
6. synchronized锁在升级之后不支持降级，如在业务流量高峰阶段升级为重量级锁，流量降低时还是重量级，效率较低（有些JVM实现支持降级，但是降级条件极为苛刻，对于Java线程来说可基本认为是不支持降级）
7. 线程间通信无法按条件进行线程的唤醒，如生产者消费者场景中生产者完成数据生产后无法做到只唤醒消费者，其他等待的生产者也会被同时唤醒

# 图解http阅读笔记

## 第1章——了解web及网络基础

### 1.1使用 HTTP 协议访问 Web

Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议  [**超文本转移协议**] --[关于HTTP中文翻译的讨论](https://www.ituring.com.cn/article/1817)）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。

### 1.2 HTTP 的诞生

- HTTP/0.9 —— HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被称为HTTP/0.9。
- HTTP/1.0 —— HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为HTTP/1.0，并记载于 RFC1945。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。
- HTTP/1.1 —— 1997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 RFC2616 就是当前的最新版本。
- HTTP/2.0 —— [深入理解http2.0协议，看这篇就够了！](https://juejin.cn/post/6844903984524705800)

>当年 HTTP 协议的出现主要是为了解决文本传输的难题。由于协议本身非常简单，于是在此基础上设想了很多应用方法并投入了实际使用。现在 HTTP 协议已经超出了 Web 这个框架的局限，被运用到了各种场景里。

### 1.3 网络基础 TCP/IP

通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205182048444.png" alt="image-20220518204827357" style="zoom:80%;" />

TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。分层的好处在于，当协议某个部分需要变动时不需要整体的替换掉整个协议，只需替换变动的层即可，将各层之间的接口做好规划就可以让每个内部的层自由设计，同时层次化之后设计也更加简单，各个层只需考虑自身的功能实现即可。

**TCP/IP 协议族各层的作用如下：**

- 应用层

  应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File
  Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。HTTP 协议也处于该层。

- 传输层

  传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。

- 网络层（又名网络互连层）

  网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。

- 链路层（又名数据链路层，网络接口层）

  用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。

利用 TCP/IP 协议族进行数据交互时会按分层依次传递数据，发送端自顶向下发送传输数据时每经过一层就会打上一个首部信息，接受层自底向上接受数据时会一层一层去掉首部信息，这种数据的包装方法称之为**封装**。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205182100125.png" alt="image-20220518210049045" style="zoom:80%;" />

### 1.4 与 HTTP 关系密切的协议 : IP、TCP 和DNS

- 负责传输的 IP 协议

  IP 间的通信依赖 MAC 地址（**物理地址**，基本上是唯一且不变的）。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时，会采用 ARP 协议（AddressResolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。

- 确保可靠性的 TCP 协议

  TCP位于传输层，提供可靠的字节流服务，为保证可靠，TCP在将数据包送出去后通过三次握手等一些手段来保证通信的可靠性。

- 负责域名解析的 DNS 服务

  DNS是位于应用层的协议，它提供域名到 IP 地址之间的解析服务，DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。

各种协议与 HTTP 协议的关系：

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205182115635.png" alt="image-20220518211544521" style="zoom:90%;" />

### 1.5 URI 和 URL

与 URI（统一资源标识符）相比，我们更熟悉 URL（UniformResource Locator，统一资源定位符）。URI 用字符串标识**某一互联网资源**，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的**子集**。

> 表示指定的 URI，要使用涵盖全部必要信息的**绝对 URI、绝对 URL 以及相对 URL**。相对 URL，是指从浏览器中基本 URI 处指定的 URL，形如 /image/logo.gif。

URI格式如下:

![image-20220519091917432](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205190919505.png)

- 登录信息：此项为可选项
- 服务器地址：可以使DNS可解析的域名，也可以是IPv4或IPv6地址名
- 服务器端口号：此项是可选项，忽略则自动使用默认的端口号
- 查询字符串和片段标识符：此项是可选项

## 第2章——简单的 HTTP 协议

### 2.1 HTTP 协议用于客户端和服务器端之间的通信

> 应用 HTTP 协议时，必定是一端担任**客户端**（请求访问文本或图像等资源的一端）角色，另一端担任**服务器端**（提供资源响应的一
> 端）角色

有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是
确定的，而用 HTTP 协议能够明确区分哪端是客户端，哪端是服务器端。

### 2.2 通过请求和响应的交换达成通信

HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205190934954.png" alt="image-20220519093417894" style="zoom:80%;" />

![image-20220519093959468](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205190939541.png)

### 2.3 HTTP 是不保存状态的协议

HTTP 是一种不保存状态，即**无状态**（stateless）协议。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性。但为了实现期望的保持状态功能，于是引入了 `Cookie` 技术。有了 `Cookie` 再用 HTTP 协议通信，就可以管理状态了。

### 2.4 请求 URI 定位资源

HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。

例外：如果不是访问特定资源而是对服务器本身发起请求，可以用一个 * 来代替请求 URI。

```
OPTIONS * HTTP/1.1
```

### 2.5 告知服务器意图的 HTTP 方法

- GET ：获取资源

  GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。

- POST：传输实体主体

  POST 方法用来传输实体的主体。然后接受返回的响应

- PUT：传输文件

  PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。

- HEAD：获得报文首部

  HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。

- DELETE：删除文件

  DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。

- OPTIONS：询问支持的方法

  OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

- TRACE：追踪路径

  TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。**不常用**。

- CONNECT：要求用隧道协议连接代理

  CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205191043116.png" alt="image-20220519104315062" style="zoom:90%;" />

### 2.6 持久连接节省通信量

在HTTP协议的初始版本中每进行一次通信就要创建和断开一次TCP连接，随着网络的发展，传输内容不再局限于容量很小的文本，大容量的图片多了以后每次请求都会造成无谓的通信开销。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205191325099.png" alt="image-20220519132500031" style="zoom:80%;" />

所谓为了解决这个问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或
HTTP connection reuse）的方法。持久连接的**特点**是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

> 在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。

同时持久化连接使得**管线化**成为可能，不用等待响应即可发送下一个请求，速度更快。

### 2.7 使用 Cookie 的状态管理

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

## 第3章——HTTP 报文内的 HTTP信息

### 3.1 HTTP 报文

用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。
HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。

![image-20220519133616293](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205191336344.png)

### 3.2 请求报文及响应报文的结构

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205191417393.png" alt="image-20220519141746286" style="zoom:90%;" />

- 请求行：包含用于请求的方法，请求 URI 和 HTTP 版本
- 状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本
- 首部字段：包含表示请求和响应的各种条件和属性的各类首部，一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部

### 3.3 编码提升传输速率

HTTP传输数据是可以按数据原貌传输，也可以进行编码后再传输，编码后传输速率提高但是会消耗更多的cpu资源。

报文主体和实体主体的差异：

> - 报文（message）：是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。
> - 实体（entity）：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。

```
HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。
```

HTTP协议中有一种被成为内容编码的功能类似于zip压缩文件，可以在实体内容上指明编码格式压缩，由客户端接收后在解码。常用的内容编码有以下几种：

- gzip（GNU zip）
- compress（UNIX 系统的标准压缩）
- deflate（zlib）
- identity（不进行编码）

HTTP还可以将实体主体分块进行传输（分块传输编码），分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。

```
HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。
```

### 3.4 发送多种数据的多部分对象集合

HTTP 协议中采用了多部分对象集合，可以容纳多份不同类型的数据，多部分集合包含对象如下：

- multipart/form-data：在 Web 表单文件上传时使用。

  ```http
  Content-Type: multipart/form-data; boundary=AaB03x 
  --AaB03x 
  Content-Disposition: form-data; name="field1"
  
  Joe Blow 
  --AaB03x 
  Content-Disposition: form-data; name="pics"; filename="file1.txt"
  Content-Type: text/plain 
  
  ...（file1.txt的数据）... --AaB03x--
  ```

- multipart/byteranges：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。

  ```http
  HTTP/1.1 206 Partial Content
  Date: Fri, 13 Jul 2012 02:45:26 GMT 
  Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT 
  Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES 
  
  --THIS_STRING_SEPARATES 
  Content-Type: application/pdf 
  Content-Range: bytes 500-999/8000
  
  ...（范围指定的数据）... 
  --THIS_STRING_SEPARATES 
  Content-Type: application/pdf 
  Content-Range: bytes 7000-7999/8000 
  
  ...（范围指定的数据）... 
  --THIS_STRING_SEPARATES--
  ```

### 3.5 获取部分内容的范围请求

在网络传输过程中为了解决大文件传输中断需要重新开始的问题，提供了一种恢复机制，通过指定下载的实体范围实现范围请求。

![image-20220519200554801](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205192005891.png)

范围请求的几种形式：

```java
//5001~10 000 字节
Range: bytes=5001-10000
//从 5001 字节之后全部的
Range: bytes=5001-
//从一开始到 3000 字节和 5000~7000 字节的多重范围
Range: bytes=-3000, 5000-7000
```

### 3.6 内容协商返回最合适的内容

在访问web网站时可能存在语言或者其他差异，导致同一个URI呈现出的页面是不同的，比如说当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）

> 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

内容协商技术有以下 3 种类型：

1. 服务器驱动协商（Server-driven Negotiation）

   由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。

2. 客户端驱动协商（Agent-driven Negotiation）

   由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。

3. 透明协商（Transparent Negotiation）

   是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

## 第4章——返回结果的 HTTP 状态码

### 4.1 状态码告知从服务器端返回的请求结果

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出
现了错误。状态码类别如下:

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

记录在案的状态码种类繁多，但是只需要了解具有代表性的状态码即可。

### 4.2 2XX 成功

- 200 OK

  表示从客户端发来的请求在服务器端被正常处理了

- 204 No Content

  该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。
  
- 206 Partial Content

  该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

### 4.3 3XX 重定向

- 301 Moved Permanently

  永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。

- 302 Found

  临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

- 303 See Other

  该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。

  > 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。

  ![image-20220520112626981](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205201126049.png)

- 304 Not Modified

  该状态码表示客户端发送附带条件的请求（指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部）时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。

- 307 Temporary Redirect

  临时重定向。该状态码与 302 Found 有着相同的含义。但是307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响
  应时的行为，每种浏览器有可能出现不同的情况。

### 4.4 4XX 客户端错误

- 400 Bad Request

  该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。（浏览器会像 200 OK 一样对待该状态
  码）

- 401 Unauthorized

  该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示
  用 户认证失败。

- 403 Forbidden

  该状态码表明对请求资源的访问被服务器拒绝了，可能是未获得访问权限等原因，服务器端可以选择是否给出拒绝的详细理由。

- 404 Not Found

  该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

### 4.5 5XX 服务器错误

- 500 Internal Server Error

  该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。

- 503 Service Unavailable

  该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 第5章——与 HTTP 协作的 Web 服务器

### 5.1 用单台虚拟主机实现多个域名

一台物理意义上的服务器可以通过虚拟主机（Virtual Host，又称虚拟服务器）的功能实现多个域名，这些域名通过DNS解析后是同一个ip地址，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。

### 5.2 通信数据转发程序 ：代理、网关、隧道

- 代理

  代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。使用代理服务器的优点有：通过缓存技术缓解网络带宽，对特定网站实施访问控制等。按使用方法可以大致分为两类，一种是否使用缓存，一种是否会修改报文。

  ![image-20220521092310909](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205210923003.png)

  - 缓存代理

    代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。

  - 透明代理

    转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理

- 网关

  利用网关可以由 HTTP 请求转化为其他协议通信,利用网关可以提高通信的安全性，因为可以在客户端和网关之间的通信线路上加密。

- 隧道

  隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

### 5.3 保存资源的缓存

缓存指的是在代理服务器（上文中说到的缓存代理类型）或者在客户端本地磁盘保存一些资源副本，在下次访问这些资源时可以直接获取，减少对服务器的访问。

使用缓存时要注意缓存的有效期限，因为有可能在服务器上的某个资源被请求后缓存在了客户端本地，然后服务器上的资源被改动了，这时客户端再去请求得到的是本地缓存的旧的资源，类似于数据库中的缓存一致性问题。所以缓存一般要设置一个过期时间当过期了再去重新获取资源以及一些其他的办法来确保缓存数据是同服务器上的资源是一致的。

## 第6章——HTTP 首部

### 6.1 HTTP 报文首部

- HTTP 请求报文

  在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。

  ```http
  GET / HTTP/1.1
  Host: hackr.jp
  User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/2010010
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0
  Accept-Language: ja,en-us;q=0.7,en;q=0.3
  Accept-Encoding: gzip, deflate
  DNT: 1
  Connection: keep-alive
  If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT
  If-None-Match: "45bae1-16a-46d776ac"
  Cache-Control: max-age=0
  ```

- HTTP 响应报文

  在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。

  ```http
  HTTP/1.1 304 Not Modified
  Date: Thu, 07 Jun 2012 07:21:36 GMT
  Server: Apache
  Connection: close
  Etag: "45bae1-16a-46d776ac"
  ```

### 6.2 HTTP 首部字段

HTTP 首部字段是构成 HTTP 报文的要素之一，使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。首部字段由字段名和字段值构成，中间用冒号分割，另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示：

```http
Keep-Alive: timeout=15, max=100
```

> **若 HTTP 首部字段重复了会如何？**
> 当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑
> 的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。

HTTP 首部字段根据实际用途被分为以下 4 种类型：

1. 通用首部字段（General Header Fields）

   请求报文和响应报文两方都会使用的首部。

2. 请求首部字段（Request Header Fields）

   从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

3. 响应首部字段（Response Header Fields）

   从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

4. 实体首部字段（Entity Header Fields）

   针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

HTTP/1.1 规范定义了 47 种首部字段--》[HTTP/1.1 首部字段一览表](https://blog.nowcoder.net/n/d23f4fb5b9414589bbdcff6b15053ea3)

非 HTTP/1.1 首部字段：

```java
在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。
```

HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。

- 端到端首部（End-to-end Header）

  首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。

- 逐跳首部（Hop-by-hop Header）

  首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提
  供 Connection 首部字段。

### 6.3 HTTP/1.1 通用首部字段

1. Cache-Control

   通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。指令的参数是可选的，多个指令之间通过“,”分隔。例如：

   ```http
   Cache-Control: private, max-age=0, no-cache
   ```

   - 缓存请求指令：

     | 指令              | 参数   | 说明                                                         |
     | ----------------- | ------ | :----------------------------------------------------------- |
     | no-cache          | 无     | 强制向源服务器再次验证，防止从缓存中返回过期的资源           |
   | no-store          | 无     | 不缓存请求或响应的任何内容                                   |
   | max-age = [ 秒]   | 必需   | 响应的最大Age值，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器 |
   | max-stale = [ 秒] | 可省略 | 接收已过期的响应，如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale指定的时间内，仍旧会被客户端接收。 |
   | min-fresh = [ 秒] | 必需   | 期望在指定时间内的响应仍有效，例如 Cache-Control:min-fresh=60，这就要求缓存服务器发送60秒内的数据。 |
   | no-transform      | 无     | 代理不可更改媒体类型                                         |
   | only-if-cached    | 无     | 仅从缓存获取资源，若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。 |
   | cache-extension   | -      | 新指令标记（token）                                          |

   - 缓存响应指令：

     | 指令 | 参数 | 说明 |
     | ---- | ---- | ---- |
     | public|无|可向任意方提供响应的缓存，其他用户也可以利用缓存|
     |private|可省略|仅向特定用户返回响应，其他用户发送的请求不会返回缓存|
     |no-cache|可省略|如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存；若报文首部字段 Cache-Control 中对 no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。|
     |no-store|无|不缓存请求或响应的任何内容|
     |no-transform|无|代理不可更改媒体类型，这样做可防止缓存或代理压缩图片等类似操作|
     |must-revalidate|无|可缓存但必须再向源服务器进行确认，使用 must-revalidate 指令会忽略请求的 max-stale 指令|
     |proxy-revalidate|无|要求中间缓存服务器对缓存的响应有效性再进行确认|
     |max-age = [ 秒]|必需|响应的最大Age值|
     |s-maxage = [ 秒]|必需|公共缓存服务器响应的最大Age值，使用后直接忽略对 Expires 首部字段（实体主体过期的日期时间）及max-age 指令的处理|
     |cache-extension|-|新指令标记（token）|
     

2. Connection

   作用有如下两种：

   - 控制不再转发给代理的首部字段

     <img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205211148525.png" alt="image-20220521114839454" style="zoom:90%;" />

   - 管理持久连接

     HTTP/1.1 版本的默认连接都是持久连接，若想断开持久连接则指定Connection 首部字段的值为 Close。而HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。想要维持持续连接则需要指定Connection 首部字段的值为 Keep-Alive。

3. Date

   首部字段 Date 表明创建 HTTP 报文的日期和时间。

   ```java
   //HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式
   Date: Tue, 03 Jul 2012 04:40:59 GMT 
   //之前的 HTTP 协议版本中使用在 RFC850 中定义的格式
   Date: Tue, 03-Jul-12 04:40:59 GMT
   //C 标准库内的 asctime() 函数的输出格式
   Date: Tue Jul 03 04:40:59 2012
   ```

4. Pragma

   Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义。规范定义的形式唯一，如下所示。

   ```http
   Pragma: no-cache
   ```

5. Trailer

   首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。

6. Transfer-Encoding

   首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。HTTP/1.1 的传输编码方式仅对分块传输编码有效。

7. Upgrade

   首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。

8. Via

   使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。

9. Warning

   该首部通常会告知用户一些与缓存相关的问题的警告。格式如下。最后的日期时间部分可省略。

   ```
   Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])
   ```

### 6.4 请求首部字段

1. Accept

   Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。q代表权重值，用分号（;）进行分隔，1最大，0最小，进度小数点后三位。

   ```http
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0
   ```

2. Accept-Charset

   Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。q同上

   ```http
   Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
   ```

3. Accept-Encoding

   用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。q同上

   ```http
   Accept-Encoding: gzip, deflate
   ```

4. Accept-Language

   首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级（同上）。

   ```http
   Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3
   ```

5. Authorization

   用来告知服务器，用户代理的认证信息（证书值）

6. Expect

   客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。

7. From

   用来告知服务器使用用户代理的用户的电子邮件地址。

8. Host

   用来告知服务器自己请求资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段，因为他和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联。若服务器未设定主机名，那直接发送一个空值即可。

9. If-Match

   形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

   ![image-20220521145647503](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205211456564.png)

10. Max-Forwards

    通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最
    大数目。每转发一次就减一，为0时直接返回响应。

11. Proxy-Authorization

    接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。

12. Range

    对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。如：请求获取从第 5001 字节至第
    10000 字节的资源。

    ```http
    Range: bytes=5001-10000
    ```

13. Referer

    首部字段 Referer 会告知服务器请求的原始资源的 URI。

14. TE

    首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。

15. User-Agent

    User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。

### 6.5 响应首部字段

1. Accept-Ranges

   首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，可处理范围请求时指定其字段值为 bytes，反之则指定其为 none。

2. Age

   表示源服务器在多久前创建了响应。字段值的单位为秒。

3. ETag

   告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。有强弱之分，强ETag值只要实体发生改变就会改变；弱的只有资源发生了根本改变才会改变，会在字段值最开始加“W/”。

4. Location

   可以将响应接收方引导至某个与请求 URI 位置不同的资源。基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。

5. Proxy-Authenticate

   会把由代理服务器所要求的认证信息发送给客户端。

6. Retry-After

   告知客户端应该在多久之后再次发送请求，主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。

7. Server

   知客户端当前服务器上安装的 HTTP 服务器应用程序的信息

   ```http
   Server: Apache/2.2.6 (Unix) PHP/5.2.5
   ```

8. Vary

   可对缓存进行控制。它决定了对于未来的一个请求头，应该用一个缓存的回复(response)还是向源服务器请求一个新的回复。

   **扩展阅读：[轻松理解HTTP缓存策略](https://segmentfault.com/a/1190000038562294)**

9. WWW-Authenticate

   用于 HTTP 访问认证,它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）

### 6.6 实体首部字段

> 实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。

1. Allow

   用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。

2. Content-Encoding

   告知客户端服务器对实体的主体部分选用的内容编码方式。

3. Content-Language

   首部字段 Content-Language 会告知客户端，实体主体使用的自然语言

4. Content-Length

   表明了实体主体部分的大小（单位是字节）。

5. Content-Location

   给出与报文主体部分相对应的 URI。

6. Content-MD5

   是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。

7. Content-Range

   针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。

8. Content-Type

   说明了实体主体内对象的媒体类型。

9. Expires

   将资源失效的日期告知客户端。

10. Last-Modified

    指明资源最终修改的时间。

### 6.7 为 Cookie 服务的首部字段

管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。

- Set-Cookie（响应首部字段）

  |属性|说明|
  |---------------|--------------|
  |NAME=VALUE|赋予 Cookie 的名称和其值（必需项）|
  |expires=DATE|Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|
  |path=PATH|将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）|
  |domain=域名|作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）|
  |Secure|仅在 HTTPS 安全通信时才会发送 Cookie|
  |HttpOnly|加以限制，使 Cookie 不能被 JavaScript 脚本访问,|

- Cookie（请求首部字段）

  首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。

### 6.8 其他首部字段

> HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。

1. X-Frame-Options （响应首部）

   用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：

   - DENY ：拒绝
   - SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。

2. X-XSS-Protection （响应首部）

   针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下：

   - 0 ：将 XSS 过滤设置成无效状态
   - 1 ：将 XSS 过滤设置成有效状态

3. DNT （请求首部）

   Do Not Track的简称，拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：

   - 0 ：同意被追踪
   - 0 ：同意被追踪

4. P3P （响应首部）

   通过利用 P3P（The Platform for
   Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。

## 第 7 章 确保 Web 安全的 HTTPS

### 7.1 HTTP 的缺点

1. 通信使用明文可能会被窃听

   由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体进行加密。

   TCP/IP 是可能被窃听的网络

   按TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视，互联网上的任何角落都存在通信内容被窃听的风险，即使经过加密也可以窥视到加密处理后的信息，但是这可能会让人无法破解这些信息。

   - 加密处理防止被窃听

     目前防止窃听保护信息的对策中，有对通信的加密，通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL。

     另一种是对内容的加密，客户端需要对 HTTP 报文进行加密处理后再发送请求。需要注意的是报文首部是不进行加密的，同事要求客户端和服务端都需要具备加密和解密机制，但任然有内容被篡改的风险。

2. 不验证通信方的身份就可能遭遇伪装

   - 任何人都可以发起请求

     HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患：

     - 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器，有可能是伪装的服务器。
     - 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端，有可能是伪装的客户端。
     - 无法确定正在通信的对方是否具备访问权限。
     - 无法判定请求是来自何方、出自谁手。
     - 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。

   - 无法查明对方的证书

     使用HTTP无法确定通信方，但是可以使用SSL提供的证书手段确定通信方，证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。通过使用证书可以减少个人信息泄露的危险，也可以用于对web网站的认证。

3. 无法证明报文完整性，可能已遭篡改

   所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。

   - 接收到的内容可能有误

     没有任何办法确认，发出的请求 / 响应和接收到的请求 / 响应是前后相同的。

     ![image-20220522103025274](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205221030356.png)

   - 如何防止篡改

     常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。但这些方法无法百分百确保结果正确，而且被篡改的情况下用户也无法察觉。更好的办法使用过https。

### 7.2  HTTP+ 加密 + 认证 + 完整性保护=HTTPS

1. HTTP 加上加密处理和认证以及完整性保护后即是HTTPS

2. HTTPS 是身披 SSL 外壳的 HTTP

   HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。

   ![image-20220522104218439](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205221042500.png)

   在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。

3. 相互交换密钥的公开密钥加密技术

   SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。近代加密算法中一般加密算法是公开的，秘钥是保密的，通过这种方式确保加密的安全性，一般来说只要拿到秘钥就可以进行解密了。

   - 共享密钥加密的困境

     加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密。共享秘钥的方式需要将秘钥也发给对方依旧意味着秘钥的暴露，所以需要解决秘钥安全转交的问题。

   - 使用两把密钥的公开密钥加密

     需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。

     **相关阅读：[对称密钥加密（私钥加密） 和 非对称密钥加密（公钥加密）](https://blog.csdn.net/iw1210/article/details/53064091)**

   - HTTPS 采用混合加密机制

     HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制,因为公开密钥加密虽然安全但是速度很慢，所以一般会在交换秘钥环节用公开密钥加密，然后建立通信交换报文阶段用共享秘钥加密。

     ![image-20220522105917761](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205221059836.png)

4. 证明公开密钥正确性的证书

   公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。公开密钥也有可能在传输途中被篡改。所以为了解决上述问题，可以使用由数字证书认证机构（CA，CertificateAuthority）和其相关机关颁发的公开密钥证书。

   ![image-20220522135128491](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205221351589.png)

5. HTTPS 的安全通信机制

   ![image-20220522135248830](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205221352938.png)

   > 1. 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）
   > 2. 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应154答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
   > 3. 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
   > 4. 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。
   > 5. SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。
   > 6. 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
   > 7. 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
   > 8. 服务器同样发送 Change Cipher Spec 报文。
   > 9. 服务器同样发送 Finished 报文。
   > 10. 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。
   > 11. 应用层协议通信，即发送 HTTP 响应。
   > 12. 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。

6. HTTPS的一些缺点

   首先就是https一般比http慢2~100倍，因为一是通信慢，二是加密耗时导致慢。而且要使用https就必须要购买证书，这也是一项不菲的开销，所以一般在敏感信息等数据是采用https，其他的采用http即可。

## 第8章——确认访问用户身份的认证

### 8.1 何为认证

认证就是确保此刻坐在这个电脑面前的人就是浏览器上显示的用户，而不是伪造的或者是假扮的，为了确认用户需要核对一下信息：

密码，动态令牌，数字证书，生物认证，身份证等等。HTTP/1.1 使用的认证方式如下所示：

1. BASIC 认证（基本认证）
2. DIGEST 认证（摘要认证）
3. SSL 客户端认证
4. FormBase 认证（基于表单认证）

### 8.2 BASIC 认证

BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信
客户端之间进行的认证方式。

![image-20220522142738247](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205221427319.png)

BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。

### 8.3 DIGEST 认证

为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的方式
（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。

![image-20220522142922780](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202205221429857.png)

DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网站对高度安全等级的追求标准。因此它的适用范围也
有所受限。

### 8.4 SSL 客户端认证

SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。认证的步骤如下：

1. 接收到需要认证资源的请求，服务器会发送 CertificateRequest 报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。
3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。

多数情况下，SSL客户端认证会和表单认证结合形成一种双因素认证，通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器。

### 8.5 基于表单认证

基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。对于 Web 网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由 Web 应用程序各自实现基于表单的认证方式。每个网站一般都有各自的认证实现方式，基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理Session（会话）。

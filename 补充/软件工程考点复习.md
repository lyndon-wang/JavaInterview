# 软件工程考点复习

## 第一章

软件的定义
软件概念的提出
软件危机    表现
软讲工程的定义
三要素，工具方法过程

## 第二章

### 每种模型的特点

```
模型：模型是为了理解事物而对事物做出的一种抽象，忽略了不必要的细节，是事物的一种抽象形式。
```

#### 1.瀑布模型

![image-20220618193041321](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-5/202206181930390.png)

```
特点：文档驱动，上一阶段的变换结果是下一阶段变换的输入，相邻两个阶段具有因果关系，紧密相关。
```

>优点：
>
>（1）各阶段明确划分，原理简单，容易掌握
>
>（2）各阶段间都有验证和确认环节，以保证质量管理
>
>（3）主要用于支持结构化方法
>
>缺点：
>
>（1）是线性的软件开发模型，缺乏灵活性和回溯性，不能适应用户需求的变化
>
>（2）直到项目结束才能显示系统的能力，增加了项目的风险
>
>适合场景：
>
>（1）有一个稳定的产品定义和很容易理解的技术解决方案时
>
>（2）对一个定义的很好的版本进行维护或将一个产品移植到一个新的平台
>
>（3）那些容易理解但很复杂的项目，因为可以用顺序方法处理问题

#### 2.快速原型模型

![image-20220618201427361](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206182014413.png)

```
要点：
（1）原型系统仅包括未来系统的主要功能，以及系统的重要接口。
（2）为了尽快向用户提供原型，开发原型系统时应尽量使用能缩短开发周期的语言和工具。
```

>优点：
>
>（1）增强了开发者和用户的交流，有助于满足用户的真实需求
>
>（2）用户可及早得到可用的产品，及早发现问题并纠正错误
>
>（3）减少了技术应用风险，可降低开发费用，缩短开发周期
>
>缺点：
>
>（1）对设计人员水平及开发环境要求较高
>
>（2）难以彻底测试，更新文档较为困难
>
>（3）如果缺乏严格的过程管理，很可能退化为一种原始的无计划“试-错-改”模式

#### 3.增量模型

![image-20220618201540124](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206182015189.png)

```
该模型有一个假设，即需求可以分段成为一系列增量产品，每一增量可以分别开发。作为瀑布模型的第一个变体，可以看作是重复执行的多个瀑布模型
```

>具有瀑布模型的所有优点，此外：
>
>（1）可分批次提交软件产品，方便用户及时了解软件开发进展情况，及早发现问题
>
>（2）以组件为单位进行软件开发，降低了软件开发风险
>
>（3）开发顺序灵活，优先级最高的服务首先交付
>
>缺点：
>
>（1）由于对整个软件系统的需求没有一个完整的定义，会给总体设计带来麻烦
>
>（2）在把每个新的增量构件集成到现有软件结构中时，必须不破坏原来已开发的产品
>
>（3）软件的体系结构必须是开放的，即向现有产品中加入新构件的过程必须简单方便。每次增量开发的产品都应是可测试、可扩充的。
>
>（4）软件过程的控制失去整体性，容易退化为边做边改模型。
>
>适合场景：
>
>（1）需求可能发生变化，客户接受分阶段交付
>
>（2）分析设计人员对应用领域不熟悉，难以一步到位
>
>（3）项目风险高

```http
增量模型与瀑布模型、原型模型关系：
（1）增量模型融合了瀑布模型和快速原型模型。增量模型由一系列瀑布模型组成。原型模型开发一个原型给用户，根据用户的使用和评价修改原型，增量模型也有类似过程。
（2）增量模型与原型模型不同，原型模型的原型系统是为了明确产品需求，最终被废弃。增量模型的每一个增量都是发布的产品。
（3）需求的变化是不可避免的，增量模型适应这种变化的能力大大优于瀑布模型和原型模型
```

#### 4.喷泉模型

![image-20220619162443668](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191624765.png)

```
迭代，无缝，主要应用于面向对象开发过程
```

>优点：
>
>喷泉模型不像瀑布模型那样，需要分析活动结束后才开始设计活动，设计活动结束后才开始编码活动，该模型的各个阶段没有明显的界限，开发人员可以同步进行开发，反映了软件过程的并行性。可以提高软件项目开发效率，节省开发时间，适应于面向对象的软件开发过程。
>
>缺点：
>
>由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，不利于项目的管理且文档管理难度加大。

#### 5.螺旋模型

![image-20220619162532517](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191625591.png)

```
螺旋模型=瀑布模型+原型模型
对于复杂大型软件，开发一个原型往往达不到要求。
强调了其他模型忽视的风险分析。
周期长，适合大型复杂软件。
```

### 常用软件模型主要特点

| 开发模型     | 主要特点                                             | 适用场合                 |
| ------------ | ---------------------------------------------------- | ------------------------ |
| 瀑布模型     | 线性，整体开发，文档驱动，每一阶段必须完成指定的文档 | 需求明确的中小型软件开发 |
| 快速原型模型 | 用户参与较早，通过迭代完善用户需求，应用快速开发工具 | 需求模糊的小型软件开发   |
| 增量模型     | 每次迭代完成一个增量，可用于面向对象开发             | 容易分块的大型软件开发   |
| 喷泉模型     | 具有迭代和无间隙特特性，各阶段开发无明显边界         | 面向对象的软件开发       |
| 螺旋模型     | 典型迭代模型，是风险驱动模型，可用于面向对象开发     | 风险较大的大型软件开发   |

### 思考题

```
为以下各系统提出合适的软件过程模型，并阐述理由。
（1）汽车防锁死刹车控制系统——螺旋
（2）一个支持软件维护的虚拟现实系统——增量
（3）大学记账系统，准备替换一个已存在的系统——瀑布
（4）一个位于火车站的交互式火车车次查询系统——快速原型
```

## 第三章

### 可行性分析内容

>（1）技术可行性：技术、人员、硬件、软件
>
>（2）经济可行性：成本、效益
>
>（3）运行可行性（用户使用可行性) ：用户类型（外行、熟练、专家），操作习惯，计算机配置情况
>
>（4）法律可行性：专利，著作权，软件保护条例，信息安全，个人隐私

### 系统利益相关者

```
系统利益相关者包括以某种方式受到系统影响的任何人以及在系统中存在某种合法权益的任何人。
```

>利益相关者：
>
>-系统的最终用户
>
>-系统打算支持的业务过程描述以及与这些过程相关的人员
>
>-可能会受到系统引入影响的人员-系统的管理人员
>
>-开发和维护系统的工程师和维护人员
>
>-系统的监管机构和认证机构等

实例：银行自动柜员机系统的利益相关者

-当前银行客户-其他银行代表-硬件和软件维护工程师-市场开发部-银行管理者-柜台职员-数据库管理员-信息安全管理员

### 非功能需求原则  

软件需求分类——包括**功能需求**和**非功能需求**，**功能需求**描述了软件要执行的功能，包括对系统提供的服务、如何对输入做出反应以及系统在特定条件下的行为描述；**非功能需求**是对解决方案的性能约束或质量需求，是指不直接与系统具体功能相关的一类需求，与系统的**总体特性**有关，如可维护性、安全性、可靠性、反应时间、存储空间等需求

![image-20220619164604068](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191646124.png)

> 非功能需求原则  ：应定量描述非功能需求使需求可被客观测试。
>
> 例：系统应当对医护人员而言容易使用，并且应当能通过某种方式进行组织，以使得用户错误能够最小化。
>
> 医护人员应当在2小时的培训后有能力使用所有的系统功能。接受培训后，有经验的用户所犯的错误的平均数量不应当超过每小时（系统使用时间）2个。

### (需求的特性 原则 需求获取的常用技术)

1. 需求的特性

   -多样性：功能、性能、行为、过程、数据

   -变化：随着对软件认识的加深

   -需要挖掘：由直观到本质

   -并非都是需求：提炼

2. 需求的原则

   -无二义性、精确性、可验证性：避免交付时争议，简化方式解读模糊需求，修改导致成本增加和延期

   -完整性：用户需要的所有服务和信息都应该被定义（大型复杂系统易犯错和遗漏，系统利益相关者）

   -一致性：需求不应该自相矛盾（大型系统中很多利益相关者的背景和期望值不同）

   -有优先级

   -可量化：可度量、开发费用

   -折中：无止境

   -必要性

   -可行性

   -正确性

3. 需求获取常用技术

   -需求来源发现需求：领域分析，利益相关者

   -询问、面谈技巧

   - 封闭式访谈：利益相关者回答一些预定义问题
   - 开放式访谈：没有预定义的日程，需求工程团队与系统利益相关者探索一系列问题，并得到对他们需求的更好的理解

### 数据流图

```
简称DFD，从数据传递和加工的角度出发，刻画数据流从输入到输出的移动和变换过程，它能够清晰的反映系统必须完成的逻辑功能。
```

步骤：

1.  先画顶层数据流图，顶层流图只包含一个加工，用以表示被开发的系统，然后考虑该系统有哪些输入数据、输出数据流，画出整个系统的输入输出。顶层图的作用在于表明被开发系统的范围以及它和周围环境的数据交换关系。

2. 从顶层数据流图开始，逐层对系统进行分解，每分解一次，系统的加工数量就增多一次，每个加工的功能也更具体一些。继续分解，直到所有加工足够简单，不必再分解为止。不再分解的加工称为基本加工。数据流图一般将层号从0开始编号，依次为0层、1层、2层……。

3. 注意事项

   - 命名：不论数据流、数据存储还是加工，合适的命名使人们易于理解其含义。
   - 画数据流而不是控制流。
   - 每个加工至少有一个输入数据流和一个输出数据流，反映出此加工数据的来源与加工的结果。**实体之间不存在数据流，实体和数据存储之间不存在数据流。**

4. 编号：如果一张数据流图中的某个加工分解成另一张数据流图时，则上层图为父图，直接下层图为子图。子图及其所有的加工都应适当编号。

5. 子图的输入输出数据流同父图相应加工的输入输出数据流必须一致，此即父图与子图的平衡。

   ![image-20220619170146255](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191701311.png)

6. 为了提高数据流图的可读性，应合理分解，把一个加工分解成几个功能相对独立的子加工，减少加工之间输入、输出数据流的数目，增加数据流图的可理解性。

### 数据流图举例-教材购销系统

```
某学校计算机教材购销系统具有以下功能：学生买书，首先填写购书单，计算机根据各班学生用书表及售书登记表审查有效性。若有效，计算机根据教材库存表进一步判断书库是否有书；若有书，计算机把领书单返回给学生，学生凭领书单到书库领书。对脱销的教材，系统用缺书单的形式通知书库，新书购进库后，也由书库将进书通知返回给系统。
请就以上系统功能画出分层的数据流图（第三层只需画出销售子系统的数据流图）。
```

1. 顶层数据流图

   <img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191707838.png" alt="image-20220619170717781" style="zoom:80%;" />

2. 第二层数据流图

   <img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191707890.png" alt="image-20220619170732826" style="zoom:80%;" />

3. 第三层数据流图

   <img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191707232.png" alt="image-20220619170755136" style="zoom:80%;" />

### 数据流图练习-进销存管理系统

```
某商品进销存管理系统的部分功能如下：
（1）仓库管理员负责输入商品的入/出库清单、维护商品库存信息、定时统计、打印商品库存的月报表给商品销售经理。
（2）销售员负责输入商品销售信息，并打印购货清单给客户，商品销售的相关信息要存入相应文件。
 请画出描述上述功能的分层数据流图（三层）。
```

1. 顶层图

   <img src="../../../.config/Typora/typora-user-images/image-20220619192005364.png" alt="image-20220619192005364" style="zoom:80%;" />

2. 一层图

   <img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191920102.png" alt="image-20220619192028036" style="zoom:80%;" />

3. 二层图

   <img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191920713.png" alt="image-20220619192040644" style="zoom:80%;" />

## 第四章

**链接->[软件工程---系统建模](https://codeantenna.com/a/wxQWCMOIMB)**

### 系统建模的视角

>1. 外部视角，**上下文模型**，对系统上下文或环境建模（定义系统上下文以及系统对其环境的依赖。）
>2. 交互视角，**交互模型（功能模型）**，对系统与参与者或系统内构件之间的交互建模
>3. 结构视角，**结构模型（静态模型）**，对系统的组成或系统处理的数据结构建模
>4. 行为视图，**行为模型（动态模型）**，对系统的动态行为以及系统如何响应事件进行建模

### 活动图

显示过程中的活动以及从一个活动到另一个活动的控制流：

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191938510.png" alt="image-20220619193812446" style="zoom:40%;" /><img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191938244.png" alt="image-20220619193858170" style="zoom: 40%;" />

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191939204.png" alt="image-20220619193955118" style="zoom: 50%;" />

### 用例图

```
用例图主要用来描述角色以及角色与用例之间的连接关系，说明的是谁要使用系统，以及他们使用该系统可以做些什么。一个用例图包含了多个模型元素，如系统、参与者和用例，并显示这些元素之间的各种关系。
```

>**参与者(Actor)**——与应用程序或系统进行交互的用户、组织或外部系统，可以是人、软件、硬件或其他与系统交互的实体，用一个小人表示。
>
>**用例(Use Case)**——外部可见的系统功能，对系统提供的服务进行描述，用椭圆表示。
>
>**子系统(Subsystem)**——用来展示系统的一部分功能，这部分功能联系紧密，用一个方框表示。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191942680.png" alt="image-20220619194242616" style="zoom:50%;" />

- **关联(Association)** ——表示参与者与用例之间的关系。
- **泛化(Inheritance)** ——继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。
- **包含(Include)** ——几个用例可以提取他们共用的用例作为子用例，使其成为自己行为的一部分，因为子用例被提出，基用例并非一个完整的用例，所以包含关系中的基用例必须和子用例一起使用才够完整，子用例也必然被执行。由基用例指向子用例。
- **扩展(Extend)** ——当某个新用例在原来的用例基础上增加了新的步骤序列，则原来用例被称为基用例，这种关系称为扩展关系。这里的基用例是一个完整的用例，即使没有子用例的参与，也可以完成一个完整的功能，只有当扩展点被激活时，子用例才会被执行。由子用例指向基用例。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191954560.png" alt="image-20220619195410477" style="zoom: 50%;" />

```
包含和扩展的区分比较：
包含关系是提取出来的用例是基用例的一部分，基用例和子用例必须一起使用才完整。扩展是从基用例的基础上扩展出新的功能（子用例），子用例不影响基用例，基用例本身是完整的，没有子用例的参与也可以完成自己的功能。二者的关键在于离开子用例，基用例是否可以完成一个完整的功能。
```

### 顺序图

```
UML中的顺序图主要用于建模参与者与系统中的对象之间的交互以及这些对象自身相互间的交互，显示在一个特定的用例或用例实例执行过程中发生的交互序列。重点不是消息本身，而是消息产生的顺序。
顺序图将交互关系表现为一个二维图，横向轴列出了参与交互的参与者和对象，纵向是时间轴。
```

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206191959097.png" alt="image-20220619195927012" style="zoom:50%;" />

> 消息：对象与对象或者对象自身之间的联系。
>
> -同步消息：消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制  
>
> -异步消息：消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。
>
> -返还消息：返还消息表示从过程调用返回。
>
> -自关联消息：自身调用以及一个对象内的一个方法调用另外一个方法。

顺序图的作用：

（1）对于业务人员，顺序图可显示不同的业务对象如何交互，有助于交流当前业务如何进行，一个业务级的顺序图可以被当作一个需求文件使用。

（2）对于需求分析人员，顺序图把用例细化为一个或者更多的顺序图，可以把用例表达的需求转化为更深层次的精细表达。

（3）对于技术人员，在设计阶段，架构师和开发者可以使用顺序图挖掘出系统对象间的交互，进一步完善整个系统的设计。

![image-20220619202610688](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206192026747.png)

### 类图

```
对象描述的是客观世界中某个具体的实体，一切事物皆对象。类描述的是一类具有相同特征的对象。
类（Class）封装了数据和行为，是具有相同属性、操作、关系的对象集合的总称。
```

绝大多数的类图分为三个部分。部分类图有五个部分。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206192020999.png" alt="image-20220509210725490" style="zoom: 80%;" />

UML类图主要是用来描述类之间的轮廓图，而类之间的常见关系就是泛化、实现、依赖、关联、聚合、组合等。表示关系的强弱：依赖 < 关联 < 聚合 < 组合 < 泛化（继承）

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206192020734.png" alt="image-20220509211334565" style="zoom: 80%;" />

**类之间关系的强弱：依赖 < 关联 < 聚合 < 组合 < 泛化（继承）**

#### 1）泛化（继承）

泛化就是继承，注意一点就是泛化也是依赖关系的一种特例，类和类，接口和接口都可以是继承关系，父类又称作基类或超类，子类又称作派生类，类继承父类后可以实现父类的所以功能，并能拥有父类没有的功能，在UML中，泛化关系可以用带空心三角形的直线来表示。

#### 2）实现

实现关系在java中就是一个类和接口之间的关系，接口中一般是没有成员变量，所有操作都是抽象的（abstract修饰），只有声明没有具体的实现，具体实现需在实现该接口的类中。在UML中实现接口用虚线和带空心的三角形表示。

#### 3）聚合

聚合关系是一种特殊的关联关系，聚合关系强调的是整体和部分的关系，其中部分**可以脱离整体而存在**。比如电视机和遥控器。

```java
class TV{
}

class Telecontrol{  //遥控器类
  private TV tv;
}
```

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206192021380.png" alt="image-20220510100303127" style="zoom:50%;" />

#### 4）组合

组合关系也是一种部分和整体的关系，但是部分存活周期受到整体的影响，其中部分**不可以脱离整体而存在**，若整体不存在则部分也将不存在。此时部分需在整体的构造方法中创建。在UML类中，组合关系用带实心菱形的直线表示。比如：高尚的说就是宜春可以没有头发但是不能没有脑袋，可怜一点的说就是宜春可以没有手和脚但是不能没有脑袋！头发、手、脚这些并不是必须要有的，组合强调的是不可分离而可以存在！如果你在大街上看到宜春没有头发，不是很正常嘛？没有手没有脚也能接受理解。那你在大街上看到宜春没有脑袋，这....

```java
class Hair{ //头发
}

class Head{ //脑袋
}

class YiChun{  //宜春
  Head head = new Head(); //Head与宜春同生共死
  private Hair hair;
}
```

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206192021204.png" alt="image-20220510100440163" style="zoom:50%;" />

#### 5）关联

关联关系是一种比较强的关系，同样也是依赖关系的特例，关联具有导航型：单向关联、双向关联 怎么理解呢，比如有两个类，一个Person类，一个身份证IDcard类

单向关联

```java
class IDcard{
}

class Person{
  private IDcard card;
}
```

双向关联

```java
class IDcard{
  private Person person;
}

class Person{
  private IDcard card;
}
```

![’](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206192021257.webp)

！！在UML类中有如下几种关联关系：

```
1..1 表示另一个类的一个对象只与该类的一个对象有关系

0..* 表示另一个类的一个对象与该类的零个或多个对象有关系

1..* 表示另一个类的一个对象与该类的一个或多个对象有关系

0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系

* 任意多个对象关联
```

#### 6）依赖

依赖关系是类与类之间最弱的关系，B调用A的方法或者属性，A变化会影响B，反之不成立。**依赖**差不多就是**使用**的意思，B使用了A的方法或属性这个时候我们就称为B依赖A。说简单点就是一个类使用了另一个类，这种关系具有临时性特征，一个类的改变由于另一类而受影响。

```java
// 1、依赖就是类中使用到了对方 2、使用可以包括：使用其成员属性、作为返回类型、作为参数类型、方法中使用到
class A{
    public void methodA(){ }
}

class B{//B依赖A
    
  public A a;

  public void methodB(){
    a.methodA();
   }
}
```

**关联与依赖的区别**

>   关联强调结构关系，依赖强调使用关系
>
>   关联可以双向，依赖是单向的
>
>   如类A和类B双向关联，则类A的对象可以作为类B中的一个属性存在，类B的对象也可以作为类A的一个属性存在
>
>   依赖是单向的，不存在作为属性的问题，类A依赖类B，则A中有三种使用B的方法，（1）类B全局（2）类B在类A中实例化    (3)类B作为参数被传递
>
>   关联一般使用实例变量，依赖一般作为方法的参数或者静态方法使用

### 状态图

```
描述系统状态以及引发状态间转换的事件，每个状态中可以包含对在该状态中所执行的动作的一个简要描述驱动一个状态转换到另一个状态的激励：带标签的箭头
```

![image-20220619202510305](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206192025488.png)

## 第五章

### 每种体系结构的概念 特性应用场合 优缺点 

#### 1.分层体系结构

```
分层体系结构中，系统功能被组织为多个分离的层次，每个层次只依赖于紧邻的下一层所提供的设施和服务。
每一层有两个角色：为上层提供服务，调用下层的服务。
```

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201000545.png" alt="image-20220620100022153" style="zoom:50%;" /><img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201004754.png" alt="image-20220620100415400" style="zoom:50%;" />

> （1）分层架构是软件架构模式的最简单形式，与其他模式相比，此体系结构模式的实现成本非常低。
>
> （2）支持增量开发，一个层次开发好之后，该层次提供的一些服务可以提供给用户。接口不变时，一个功能进行了扩展的新层可以在不影响系统其他部分的情况下取代一个已有层。
>
> （3）当一个层次的接口发生变化或增加新的设施，只有相邻的层次受影响，实现了依赖的局部化。易于提供一个应用系统的多平台实现，只需将与机器有依赖关系的层重新实现，就可以适应不同的操作系统或数据设施。
>
> >优点：
> >
> >（1）支持逐层抽象的系统设计，有利于设计者对一个复杂系统进行分解；
> >
> >（2）支持更新，因为每一层至多和相邻的上下层交互，因此功能的改变通常只影响相邻的上下层；
> >
> >（3）支持复用，如果某独立层保证了功能的完整性并且提供了文档化的接口，便可在多个语境中复用，且一组标准接口也可以使用各种不同的实现方法;
> >
> >（4）支持测试，具有定义明确的层接口提高了可测试性。
>
> >缺点：
> >
> >（1）并不是每个系统都可以很容易地划分为分层的模式，即使一个系统的逻辑结构是层次化的，出于对系统性能的考虑，系统设计师不得不把一些低级或高级的功能综合起来；
> >
> >（2）效率的降低：
> >
> >- 由分层风格构成的系统，运行效率往往低于整体结构。
> >- 在上层中的服务如果有很多依赖于最底层，则相关的数据必须通过一些中间层的若干次转化才能传到；
> >
> >（3）很难找到合适的、正确的层次抽象方法：
> >
> >- 层数太少，分层不能完全发挥这种风格的可复用性、可更改性和可移植性上的潜力。
> >- 层数过多，则引入不必要的复杂性和层间隔离冗余以及层间传输开销。
> >- 目前，没有可行的广为人们所认可的层粒度的确定和层任务的分配方法。

#### 2.MVC体系结构

```
MVC模式是许多基于Web的系统中交互管理的基础，实现了Web系统的职能分工，允许它们独立变更。
```

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201007179.png" alt="image-20220620100726107" style="zoom:67%;" />

- Model（模型）表示应用程序核心功能与数据（比如数据库记录列表）。

  模型的责任 ：（1）从数据库取出数据，并且赋予数据变量（2）负责业务逻辑实现（3）负责数据验证，然后将数据存入数据库

- View（视图）负责为用户显示信息（数据库记录），一个模型可能拥有多个视图。

  视图的责任：（1）获取用户输入（2）向controller发送处理请求（3）接收来自Controller的反馈并将model的处理结果显示给用户

- Controller（控制器）处理输入（写入数据库记录）。

  控制器的责任：（1）接收来自客户的请求（2）调用model业务逻辑方法（3）调用View显示执行结果

**数据更新：**

对于数据更新，MVC采用**改变-传播机制**(change-propagation)：

（1）如果用户通过一个view的controller改变了model，所有的view必须反映出该改变。

（2）当数据发生变化的时候，model通知所有的view，告诉他们数据已经改变了；Views可以遍历model中的数据，以便发现到底是什么改变了，并更新显示数据。

> 优点：
>
> （1）容易增加或者改变：视图事务逻辑被封装在Model中，所以在新增加一个视图的时候，不必改动模型，而是因为业务逻辑都是一样的，所以只需要新增加一个视图类即可。
>
> （2）容易独立地更新每个软件模块：由于一个应用被分离为三个软件模块，因此，我们可以独立地改变其中的一个模块，而不影响其它两个模块。例如，一个应用的业务流程或者业务规则的改变只需改动MVC的模型层。 
>
> （3）代码易开发易维护
>
> （4）业务逻辑更易测试 
>
> 缺点：
>
> （1）不适合小型或中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失；
>
> （2）对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率；
>
> （3）视图与控制器是相互分离，但也是联系紧密的部件，视图没有控制器的存在，其应用很有限，反之亦然，这样就妨碍了他们的独立重用；
>
> （4）依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据，对未变化数据的不必要的频繁访问，也将损害操作性能。

#### 三层体系架构和MVC架构对比

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201015349.png" alt="image-20220620101518062" style="zoom:80%;" />

两种架构的相似之处：

1. 都是由三部分软件模块组成的
2. 三层架构的显示层与MVC架构的View类似
3. 三层架构的应用层与MVC架构的Model类似

两种架构的区别：

1. 各个模块之间的调用关系不同三层架构的一个**根本原则**是显示层不能直接越过应用层直接调用永久数据存储层的代码。显示层必须先调用应用层，再由应用层相关的方法调用永久数据存储层，不允许有相反方向的调用。因此，**三层架构的交互是线性的**。 MVC架构的程序组件之间的交互是**三角形**的，View对象发送更新给Controller对象，Controller对象更新Model对象，并且View对象直接地从Model对象得到更新。
2. 对数据库的访问方式不同三层架构**指定一个永久数据访问层**，所有对数据库的访问均有此层承担；MVC架构没有指定专门的数据库访问模块，**一般的情况下**是由Model直接访问数据库，但也**不排除**Controller中直接访问数据库的可能。
3. 关于控制模块的不同MVC架构中存在一个专门的Controller模块；而层次架构中通常没有这样专门的模块，事实上，很多设计者在层次架构中的应用层里面**单独地指定一个类似的控制模块**。

#### 3.管道和过滤器体系结构

```
管道过滤器模式下，每个功能模块都有一组输入和输出。功能模块称为“过滤器”，“过滤掉”来自它的输入数据流中可以处理的数据。功能模块之间的连接可以看作输入输出数据流之间的通路，起到“管道” 的作用。
```

- -过滤器有相对独立性，独立完成自身功能，相互之间无需进行状态交互。
- -结果的正确性不依赖于各个过滤器运行的先后次序，各个过滤器在输入具备后完成自己的计算。

优点：

1. 设计人员可以将系统的输入输出行为理解为**单个过滤器行为的叠加和组合**。将系统**抽象成一个黑箱**，其输入是系统中第一个过滤器的输入管道，输出是系统中最后一个过滤器的输出管道，内部各功能模块的具体实现**对用户完全透明**。
2. 支持**功能模块的复用**，任何两个过滤器之间，只要它们之间传送的数据遵守共同规约，就可以连接。每个过滤器都有自己独立的输入输出接口，如果过滤器之间传输的数据**遵守共同规约**，只要用管道将它们连接就可以正常工作。
3. 具有较强的**可维护性**和可扩展性。只要遵守输入输出数据规约，旧的过滤器可以被替代，新的过滤器可以添加到已有系统。
4. 支持一些特定分析，如**吞吐量计算和死锁检测**。利用管道过滤器模式视图，可以很容易的得到系统资源使用和请求的**状态图**，然后根据操作系统原理中死锁检测方法可以分析出系统**目前所处状态**，如是否存在死锁以及如何消除死锁。
5. 具有**并发性**，每个过滤器作为一个单独的执行任务，可以与其它过滤器并发执行。过滤器的执行是**独立的**，不依赖于其他过滤器。在实际运行时可以将存在并发可能的多个过滤器看作多个并发的任务并行执行，从而加快处理速度，提高系统整体效率。

缺点：

1. **交互能力弱**，适于数据流的处理和变换，**不适合为与用户交互频繁的系统建模**。在这种模型中，每个过滤器都有自己的数据，这些数据或者是从磁盘存储器中读取来，或者是由另一个过滤器的输出导入进来，整个系统没有一个共享的数据区。这样，当用户要操作某一项数据，并涉及多个过滤器对相应数据的操作，则实现较为复杂。因此，可以对每个过滤器增加相应的用户控制接口，使得外部可以对过滤器的执行进行控制。
2. 管道-过滤器模式往往导致系统处理过程的成批操作。有时设计者不得不花精力协调两个相对独立又存在某种关系的数据流之间的关系，如多过滤器并发执行时数据流之间的**同步问题**。根据实际设计的需要，设计者也需要对数据传输进行特定的处理，如为了防止数据泄露而**采取加密**等手段，导致过滤器必须对输入、输出管道中的数据流进行解析或反解析，增加了过滤器具体实现的复杂性。
3. 虽然简单的文本输入输出可以用这种方式建模，对于图形化的用户界面，更复杂的输入输出格式及基于实践的控制策略，很难将其实现为一种符合管道和过滤器模型的顺序流。

#### **4.知识库体系结构**

```
也被称为数据共享体系结构，关注系统的静态结构，没有显示系统的运行时组织，描述了一组相互交互的构件如何共享数据。适合需要使用大量数据且数据由一个构件生成同时由另一个构件使用的应用。
采用知识库体系结构构建的系统中通常有两个功能构件：中央数据单元构件和一些相对独立的构件集合。
```

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201023414.png" alt="image-20220620102328033" style="zoom:50%;" />

> 信息交互方式的差异导致控制策略的不同，依据两种不同的控制策略，基于知识库体系结构构件的系统被分成两个子类：
>
> （1）基于传统数据库型数据共享模式的应用系统由输入流中的事件来**驱动系统进行信息处理**，把执行结果**存储到中央数据单元**。
>
> （2）基于黑板型数据共享模式的应用系统由**中央数据单元的当前状态来驱动系统运行**。
>
> >黑板型数据共享模式的应用系统包括三部分：
> >
> >（1）**知识源**：知识源中包含独立的、与应用程序相关的知识，知识源之间不直接进行通信，它们之间的交互只通过黑板来完成
> >
> >（2）**黑板数据结构**：黑板数据结构是按照与应用程序相关的层次来组织的解决问题的数据，知识源通过不断的改变黑板数据来解决问题
> >
> >（3）**控制**：控制完全由黑板的状态驱动，黑板状态的改变决定使用的特定知识
>
> 优点：
>
> 1. 知识库体系结构是一个**共享大量数据的有效方法**，不需要显式的从一个构件向另一个构件传输数据。
> 2. **解决问题的多方法性**。针对于要解决的问题，如果在其领域中没有独立的方法存在，且对解空间的完全搜索也不可行时，在黑板模式中可以**用多种不同的算法进行试验**。
> 3. **具有可修改性和可维护性**：在黑板模式中每个知识源都是独立的，彼此之间的通信通过黑板来完成。
> 4. **知识源可重用：**由于每个知识源在黑板系统中都是独立的，如果知识源和所基于的黑板系统有理解相同的协议和数据，就可以重用知识源。
> 5. **支持容错性和健壮性：**应用中的多种不同数据处理逻辑相互影响和协同来完成数据分析处理，就好像多位不同的专家在同一黑板上交流思想，每个专家都可以获得别的专家写在黑板上的信息，同时也可以用自己的分析去更新黑板上的信息，影响其它专家，这对于噪声数据和不确定的结论有很强的容错性。
>
> 缺点：
>
> 1. **测试困难：**由于黑板模式的系统由中央数据构件描述系统并体现系统的状态，系统的执行没有确定的顺序，结果的**可再现性比较差。**
> 2. **不能保证有好的求解方案**：一个黑板模式的系统提供给我们的往往是解决问题的一个百分比，而不是最佳的解决方案。
> 3. **效率低：**黑板模式的系统在拒绝错误假设的时候要承受多余的计算开销。
> 4. **开发成本高：**绝大部分黑板模式的系统需要几年的时间来进化。
> 5. **缺少对并行机的支持：**黑板模式要求黑板上的中心数据同步并发访问。
> 6. 由于构件必须围绕一个达成共识的知识库数据模型运转，如果一个新构件与数据模型不相符，则很难甚至无法集成。
> 7. 实践中很难将知识库**分布到多台不同机器**，虽然可能实现一个逻辑上的集中知识库的分布式部署，但会涉及维护数据的多份拷贝，保证拷贝的**一致性**以及及时更新给系统增加了更多的额外负担。

黑板模式对于无确定性求解策略的问题比较有用，这种模式在专家系统中应用比较广泛。目前广泛使用的专家系统一般均由知识库、数据库、推理机、咨询解释、知识获取和人机接口6个部分组成。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201034404.png" alt="image-20220620103421097" style="zoom:67%;" />

#### 5.客户-服务器体系结构

**服务器**：网络环境中承担服务并保障服务质量的高性能计算机，侦听网络上其他计算机（客户机）提交的服务请求，并提供相应的服务，如文件服务器、打印服务器、通信服务器。

**客户机**：又称工作站，服务器是为网络上许多网络用户提供服务以共享它的资源，客户机仅对操作该客户机的用户提供服务。客户机是用户和网络的接口设备，用户通过它可以与网络交换信息，共享网络资源。

根据计算量和数据存储的差别，网络连接分为**客户机/服务器体系结构**（C/S）和**浏览器/服务器体系结构**（B/S）。

描述了一种**常用的分布式系统运行时组织方式**。遵循客户-服务器模式的系统被组织为一组服务和相关联的服务器，以及访问并使用服务的客户端。该模型的主要构件包括：

1. 一组向其他构件提供服务的服务器，服务器是软件构件，多个服务器可能运行在同一台计算机
2. 一组调用服务器提供的服务的客户端，通常会有一个客户端程序的多个实例并行运行在多台计算机
3. 一个允许客户端访问这些服务的网络

> C/S架构优点：
>
> 1. 可以**充分利用两端硬件环境的优势**，将任务合理分配到客户端和服务器端实现。
> 2. 运行在不同服务器上的独立服务的逻辑模型可以被实现在单台计算机上，服务和服务器可以在不影响系统其他部分的情况下被修改，体现了**分离和独立性的优势**。
> 3. 容易增加一个新的服务器并将其与系统的剩余部分集成，或者在不影响系统其他部分的情况下**透明的升级服务器**。
> 4. 能**充分发挥客户端的处理能力**，很多工作可以在客户端处理后再提交给服务器。使得客户端**响应速度快**，能够减轻服务器的压力，而且有**更高的安全性和稳定性**。
> 5. 应用服务器运行**负载较轻**。最简单的C/S体系结构的应用由两部分组成，客户应用程序和数据库服务器程序（应用服务器），即前台程序和后台程序。一旦服务器程序被启动，就随时等待响应客户程序发来的请求，客户应用程序运行在客户电脑上，当需要对数据库中的数据进行操作时，客户程序自动寻找服务器程序，并发出请求，服务器程序根据预定规则做出应答，并返回结果。
>
> C/S架构缺点：**维护成本高且投资大**
>
> 1. C/S架构要选择适当的数据库平台实现**数据库数据的真正统一**，使分布两地的数据同步完全交由数据库系统管理，逻辑上两地的操作者要直接访问同一个数据库才能有效实现。
> 2. 应用需要建立**实时的数据同步**时，必须在两地建立实时通讯连接，保持两地的数据库服务器在线运行，网络管理人员对服务器和客户机同时维护管理。
> 3. 客户端需要安装专用的客户端软件，涉及到安装的工作量，软件升级时，每一台客户机需要重新安装，**维护和升级成本较高**。
>
> B/S架构优点：
>
> 1. 维护和升级方式简单B/S架构的软件只需要**管理服务器**，**所有客户端只是浏览器**。无论用户规模多大，有多少分支机构**都不会增加维护升级的工作量**，异地只需要把服务器连接专网，实现远程维护、升级和共享。
> 2. **成本降低，选择更多：**使用B/S架构的应用管理软件，服务器操作系统的选择很多，不管选用哪种操作系统都可以让大部分人使用Windows作为桌面操作系统。如登录网易只要安装了浏览器即可，不需要了解网易的服务器用的什么操作系统，虽然大部分网站服务器都没有使用Windows操作系统，而用户的电脑大部分是Windows操作系统。
>
> B/S架构缺点：
>
> 1. **应用服务器运行数据负载较重：**B/S架构的管理软件只安装在服务器端，网管人员只需要管理服务器，用户事物逻辑在服务器端通过WWW浏览器实现，极少部分事物逻辑在前端实现。**一旦服务器崩溃，后果不堪设想**。
>
> C/S和B/S区别：
>
> 1.  C/S建立在**局域网基础**上，B/S建立在**广域网基础**上。
> 2. 硬件环境不同 ：C/S一般建立在**专用网络，小范围的网络环境，局域网间再通过专门服务器提供连接和数据交换服务**。B/S建立在广域网，**不必是专门的网络硬件环境，有比C/S更强的适应范围，一般只要有操作系统和浏览器即可**。
> 3.  对安全要求不同：C/S一般面向**相对固定的用户群**，对信息安全的**控制能力强**，高度机密的信息系统一般采用C/S结构，可以通过B/S发布部分可公开信息。B/S建立在广域网，面向不可知的用户群，**对安全的控制能力相对弱。**
> 4.  B/S结构软件一般只有**初期一次性投入成本**，有利于软件项目控制和避免IT黑洞。C/S结构的软件随着应用范围的扩大，**投资不断。**
> 5. **应用软件的快速部署是企业快速扩张的必要保障：**C/S结构的软件，由于必须同时安装服务器和客户端、建设机房、招聘专业管理人员，无法适应企业快速扩张的特点。B/S结构软件，只需一次安装，以后只需设立账号、培训即可。

### 面向对象

优点：

（1）**高度模块性：**数据与其相关操作被组织为对象，成为模块组织的基本单位

（2）**封装功能：**一组功能和实现细节被封装在一个对象中，具有功能的接口被暴漏出来

（3）**代码共享：**对象的相对独立性可被反复使用，通过拼接形成不同的软件系统

（4）**易维护性：**对象接近于人对问题和解决方案模型的思维方式，易于理解和修改

缺点：

如果一个对象需要调用另一个对象，必须知道那个对象的标识（对象名或对象引用），如果一个对象改变了自己的标识，必须通知系统中所有和它有调用关系的对象，否则系统无法正常运行，无形中增强了对象之间的依赖关系。

## 第六章

### 模块化内聚耦合

模块独立性是把软件转换为模块时应遵循的标准。模块独立性的衡量标准：**内聚和耦合**

- 内聚：模块内部各元素之间的结合程度

- 耦合：模块和模块之间的依赖程度

### 内聚性

一个模块内各元素（语句之间、程序段之间）联系的越紧密，则它的内聚性就越高。高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201335696.png" alt="image-20220620133532292" style="zoom:67%;" />

1. **偶然内聚**：一个模块内的各处理元素之间没有任何联系，只是偶然地被凑到一起。这种模块也称为巧合内聚，内聚程度最低。
2. **逻辑内聚**：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能 。
3. **时间内聚**：把需要同时执行的动作组合在一起形成的模块称为时间内聚模块。
4. **过程内聚**：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递，即一个模块内的处理元素必须以特定次序执行。例如某个要完成登录的功能，前一个功能判断网络状态，后一个执行登录操作，显然是按照特定次序执行的。
5. **通信内聚**：指模块内所有处理元素都在同一个数据结构上操作或所有处理功能都通过公用数据而发生关联（有时称之为信息内聚）。
6. **顺序内聚**：一个模块中各个处理元素和同一个功能密切相关，而且这些处理必须顺序执行，通常前一个处理元素的输出是后一个处理元素的输入。例如某要完成获取订单信息的功能，前一个功能获取用户信息，后一个执行计算均价操作，显然该模块内两部分紧密关联。顺序内聚的内聚度比较高，但缺点是不如功能内聚易于维护。
7. **功能内聚**：模块内所有元素的各个组成部分全部都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分。即模块仅包括为完成某个功能所必须的所有成分，这些成分紧密联系、缺一不可。功能内聚是最强的内聚，优点是它的功能明确。判断一个模块是否功能内聚，一般从模块名称就能看出。如果模块名称只有一个动词和一个特定的目标（单数名词），一般来说就是功能内聚，如：“计算水费”、“计算产值”等模块。功能内聚一般出现在软件结构图的较低层次上。

### 耦合性

模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。对于低耦合，通常的理解是：一个完整的系统中，模块与模块之间，尽可能的独立存在，即让每个模块尽可能的独立完成某个特定的子功能。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。模块与模块之间的接口，尽量的少而简单。如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分。

<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201337101.png" alt="image-20220620133734738" style="zoom:67%;" />

1. **非直接耦合**：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。

2. **数据耦合**：调用模块和被调用模块之间只传递简单的数据项参数，即为了完成一些有意义的功能，将某些模块的输出数据作为另一些模块的输入数据。

3. **特征耦合**：也称作**标记耦合**，调用模块和被调用模块之间传递数据结构而不是简单数据，即特征耦合是指两个都与同一个数据结构有关的模块发生的耦合。由于同时使用同一个数据结构，当数据结构变动时,必然影响这两个模块,从而增加模块间的依赖性，降低模块独立性。在设计模块结构时,应当尽量将数据结构传递修改为数据传递,从而将特征耦合变为数据耦合,降低耦合度。

4. **控制耦合**：模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。

5. **外部耦合**：一组模块都访问同一全局简单变量，且不通过参数表传递该全局变量的信息。

6. **公共耦合**：一组模块都访问同一个全局数据环境，则称之为公共耦合。公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。如果模块只是向公共数据环境输入数据，或是只从公共数据环境取出数据，这属于比较松散的公共耦合；如果模块既向公共数据环境输入数据又从公共数据环境取出数据，这属于较紧密的公共耦合。

   > 公共耦合会引起以下问题：（1）无法控制各个模块对公共数据的存取，严重影响了软件模块的**可靠性和适应性**。（2）软件的**可维护性变差**，一个模块修改了公共数据，会影响相关模块。（3）**降低软件的可理解性**，不容易清楚知道哪些数据被哪些模块所共享，排错困难。一般地，仅当模块间共享的数据很多且通过参数传递很不方便时，才使用公共耦合。

7. **内容耦合**：一个模块直接访问另一模块的内容，被修改的模块完全依赖于修改它的模块，则称这两个模块为内容耦合。内容耦合可能在汇编语言中出现，大多数高级语言都已设计成不允许出现内容耦合。

> 高内聚低耦合的意义：短期来看，高内聚低耦合并没有很明显的好处，甚至短期内会影响系统的开发进度，因为高内聚，低耦合的系统对开发设计人员提出了更高的要求。高内聚，低耦合的好处体现在系统持续发展的过程中，高内聚，低耦合的系统具有更好的重用性，维护性，扩展性，可以更高效的完成系统的维护开发，持续的支持业务的发展，不会成为业务发展的障碍。

> 是否内聚越高越好，耦合越低越好？：并不是内聚越高越好，耦合越低越好，**高内聚和低耦合是冲突的**，真正好的设计是在高内聚和低耦合间进行**平衡**。
>
> （1）最强的内聚莫过于一个类只写一个函数，这样内聚性绝对是最高的。但这会导致类的数量急剧增多，从而导致类的耦合特别多，整个设计就变成“高内聚高耦合”。
>
> （2）最弱的耦合是一个类将所有的函数都包含了，这样类完全不依赖其它类，耦合性是最低的。但这样会带来一个明显的问题，内聚性很低，整个设计就变成了“低耦合低内聚”。

## 第七章

### 测试的作用

（1）向开发人员和客户展示软件满足其需求每一个需求（无二义性、精确性、可验证性）至少应该有一个测试

（2）找出可能导致软件行为不正确、出现不希望的行为、或行为不符合规格说明的输入或输入序列系统崩溃、不正确的输出、数据损坏等软件缺陷

### 测试的种类

（1）**确认测试:**使用一组反映系统的期望使用方式的测试用例测试系统是否正确运行

（2）**缺陷测试:**设计测试用例暴漏缺陷，穷举测试

### 软件测试三阶段

（1）**开发测试：**开发过程进行测试以发现bug和缺陷，设计者和程序员都会参与

（2）**发布测试：**一个独立的测试团队在系统发布给用户之前测试系统的完整版本，检查系统是否满足系统利益相关者的需求

（3）**用户测试：**系统的用户或潜在用户在它们自己的环境中测试系统。验收测试是一种用户测试，客户正式测试系统以决定是否从供应商接收系统，或系统是否需要进一步开发。

### 开发测试三阶段

开发测试的三个阶段：

（1）**单元测试：**对各个程序单元（一个模块、一个函数或者一个类）进行测试，关注测试对象的功能

（2）**构件测试：**对多个不同的单元进行集成创建一个复合构件，关注测试提供对构件功能进行访问的构件接口。

（3）**系统测试：**对系统中的一些或全部构件进行集成并将系统作为一个整体进行测试，关注测试构件交互。

### 单元测试的意义

（1）单元测试是所有测试中最底层的一类测试，是第一个环节，也是**最重要的一个环节**，是唯一一次保证能够代码覆盖率达到100%的测试。

（2）单元测试是整个软件测试过程的基础和前提，性价比是最好的，防止了开发的后期因bug过多而失控。

（3）错误发现的越晚，修复它的费用就越高，而且呈指数增长的趋势。

### 单元测试方法——白盒测试

```
又称结构测试, 逻辑驱动测试或基于代码的测试，以程序的内部逻辑为基础设计测试用例。测试用例由测试输入数据以及对应的预期输出结果组成。
```

1. 语句覆盖：让程序中的**每条语句都至少执行一遍**比较弱的逻辑覆盖，效果有限，必须与其它方法结合使用
2. 分支覆盖（判定覆盖）：让程序中**每个判断的取真分支和取假分支至少经历一次**比语句覆盖稍强一些，但实际效果表明，判定覆盖不能保证一定能查出在判断的条件中存在的错误
3. 条件覆盖：让每个判断中的**每个条件的可能取值至少满足一次**条件覆盖深入到判定中的每个条件，但可能不能满足判定覆盖的要求
4. 判定/条件覆盖：保证判断中**每个条件的所有可能取值至少执行一次，同时每个判断的所有可能判断结果也至少执行一次**判定/条件覆盖有缺陷，从表面上来看，它测试了所有条件的取值。但是事实往往某些条件掩盖了另一些条件，会遗漏某些条件取值错误的情况。
5. 条件组合覆盖：**所有判定中各条件判断结果的所有组合至少出现一次**这是一种相当强的覆盖准则，不但可覆盖所有条件的可能取值的组合，还可覆盖所有判断的可取分支，但可能有的路径会遗漏掉，测试还不完全。

练习题：<img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201437436.png" alt="image-20220620143743364" style="zoom: 67%;" /><img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201443332.png" alt="image-20220620144305256" style="zoom: 50%;" />

语句覆盖测试用例设计：

```
通过路径3-4-7和路径5-6-7
通过路径3-4-7:A=2,B=0,X=2
通过路径5-6-7:A=1,B=0,X=2
```

判定（分支）覆盖测试用例设计：

```
每个组合条件分别取真取假
通过路径3-4-7:A=2,B=0,X=2 
通过路径5-6-7:A=1,B=0,X=2
```

条件覆盖测试用例设计：

```
每个条件的可能取值至少满足一次，A>1,A<=1,B=0,B≠0,A=1, A≠1,X>1,X<=1
通过路径3-4-7:A=2,B=0,X=1 (A>1, B=0, A≠1 ,X<=1)
通过路径5-6-7:A=1,B=1,X=2 (A<=1, B≠0, A=1 , X>1)
```

分支(判定)/条件覆盖测试用例设计:

```
每个组合条件分别取真取假,每个条件的可能取值至少满足一次
通过路径3-4-7:A=2,B=0,X=1 (A>1, B=0, A≠1 ,X<=1)
通过路径5-6-7:A=1,B=1,X=2 (A<=1, B≠0, A=1 , X>1)
```

条件组合覆盖测试用例设计：

```
考虑每个组合条件,
①A>1且B=0②A<=1且B=0③A>1且B≠0④A<=1且B≠0
⑤A=1且X>1⑥A ≠ 1且X>1⑦A=1且X <= 1⑧A ≠ 1且X <= 1

通过路径3-4-7:A=2,B=0,X=2  ① ⑥
通过路径5-6-7:A=1,B=0,X=2 ⑤ ②
通过路径S7:A=2,B=1,X=1 ③ ⑧
通过路径S7:A=1,B=1,X=1 ⑦ ④
```

### 单元测试方法——黑盒测试

```
也称功能测试或数据驱动测试，把程序看作一个只有入口和出口的黑盒，在不考虑程序内部结构和内部特性的情况下，从输入数据和输出数据的对应关系出发进行测试。在测试过程中，只需要知道向黑盒输入什么，知道黑盒会产生什么结果
```

等价类划分法原理：

（1）把程序的输入域划分成若干部分，然后从每个部分中选取少数代表性数据作为测试用例。

（2）每一类的代表性数据在测试中的作用等价于这一类中的其他值，如果某一类中的一个例子发现了错误,这一等价类中的其他例子也能发现同样的错误。

（3）反之,如果某一类中的一个例子没有发现错误，则这一类中的其他例子也不会查出错误。

- **有效等价类**：对于程序的规格说明来说是合理的，有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。
- 无效等价类：对于程序的规格说明来说是不合理的，没有意义的输入数据构成的集合。利用无效等价类可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。

例子：

```
例1：一个文本框规定，输入字符个数为6-18位。

（1）一个有效等价类：范围内位数
（2）两个无效等价类：小于6位，大于18位

例3：绝对值函数abs() 

（1）输入正数，比如1、1.2、0.99，期待返回值与输入相同；
（2）输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；
（3）输入0，期待返回0；
（4）输入非数值类型，比如None、[]、{}，期待抛出TypeError。
```

等价类方法设计测试用例的**三个原则**：

（1）为每一个等价类规定一个唯一的编号；

（2）设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；

（3）设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。

163邮箱注册功能等价类划分：

![image-20220620145858177](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201458634.png)

### 发布测试

发布测试是对一个系统在开发团队以外使用一个特定发布进行测试的过程。发布测试主要目的是让系统的供应商确信系统足够好，产品可以发布或交付给客户。因此，发布测试必须表明系统提供了所要求的功能、性能、可依赖性，且系统不会在正常使用过程中失效。他和系统测试的区别是：

（1）系统开发团队通常不应该负责发布测试

（2）发布测试是一个确认检查的过程，目的是确保一个系统可以满足需求且满足系统客户使用，而由开发团队进行的系统测试关注发现系统中的缺陷。

1. 基于需求的测试

   基于需求的测试是一种确认而非缺陷测试，考虑每一个需求并为其创建一组测试，试图展示系统已经实现了它的需求。

2. 场景测试

   设想出典型的使用场景并使用这些场景为系统开发测试用例。一个场景是一个描述了系统可能的使用方式的故事。场景应当是现实的，真实的，场景测试应当是一个具有可信性且由一定复杂性的叙述性的故事。

3. 性能测试

   性能测试是对一个已经完成集成的系统的涌现性属性的测试。性能测试既关注展示系统满足需求又关注发现系统中的问题和缺陷。必须设计性能测试确保系统可以处理预计承受的负载，通常要运行一系列测试，不断增加负载直到系统性能变得无法承受。

### 用户测试

作用：来自用户工作环境的影响可能会对一个系统的可靠性、性能、可用性和鲁棒性产生重要的影响。

1. α测试

   一组经挑选的软件用户与开发团队密切配合工作，对软件的早期发布进行测试。

   - 用户可以发现那些对开发测试团队来说不那么明显的问题。

   - 用户可以提供关于实践的信息，帮助设计出更加现实的测试。

2. β测试

   向一组更大规模的用户提供一个软件早期发布版本，允许他们在上面进行试验，并将他们发现的问题报告给系统开发者。 

   - 参与人员可以是一组经过挑选的客户，通常是系统的早期采用者，也可以将软件公开提供出去，使任何有兴趣试用的人都可以使用。
   - β测试主要用于要在许多不同条件下使用的软件产品。与定制化产品开发者不同，普通产品开发者无法限制软件的运行环境，也无法知道所有软件产品未来的使用条件，因此可以通过β测试发现软件与它的运行环境特性之间的交互。
   - β测试也可作为一种市场营销形式，增加客户对系统的了解。

3. 验收测试

   验收测试是定制化系统开发的一个内在部分，客户用自己的数据对一个系统进行测试以确定其是否已经就绪，是否可以从系统开发者那里接收且在客户环境中进行部署。

   <img src="https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-%C2%B76/202206201520554.png" alt="image-20220620152053835" style="zoom:80%;" />

   ```
   （1）定义验收准则
   理想情况下，系统开发合同签署之前，作为系统开发合同的一部分
   （2）计划验收测试
   确定验收测试需要的资源、时间和预算，建立测试日程表，探讨所需要的需求覆盖度以及系统特征的测试顺序，定义测试过程的风险，如系统崩溃或性能不足，并探讨如何缓解这些风险。
   （3）设计验收测试用例
   同时测试系统的功能需求和非功能需求，理想情况下应提供完整的系统需求覆盖
   （4）运行验收测试
   建立用户测试环境，由于包含系统和用户之间交互的测试很难自动化，可能需要对用户进行培训
   （5）协商测试结果
   针对发现的问题进行协商以决定系统是否足够好并可以使用，就开发者对所发现问题如何修复达成一致
   （6）接受或拒绝系统
   开发者和客户进行会谈以确定系统是否可以接受，如果系统不够好，则进一步开发修复发现的问题，以及重新进行验收测试。
   ```

## 第八章

### 软件演化类别

```
（1）大部分打包软件中一个专门组织既负责最初的软件开发又负责以后的软件演化，开发和演化无缝衔接，开发过程中的过程和方法贯穿整个生命周期
（2）定制化软件通常一个软件公司为客户开发软件，由客户自己的开发团队接管系统负责演化
（3）软件用户和另外一家公司签订合同，由其负责系统的支持和演化
```

### 软件维护

```
（1）改正性维护
（2）适应性维护
（3）完善性维护
```


# 6、分层架构：功能实现的技术指导

在前面我们已经介绍了 DDD 的六边形架构与分层理论，但是还是停留在理论层面，只知道有六边形架构这个东西。可能我们还浅显地了解到了六边形架构的对比与 MVC 三层架构的优势，但还是不知道如何使用 DDD 来逻辑项目架构，本文将通过三层架构对比演进的方式给大家介绍我常用的两种 DDD 架构。

## 一、六边形架构演进之路

回顾一下 MVC 的分层架构，如下图所示：

![image-20211210204708291.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/a9d1f423a230498da865153e3a392742~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

从上往下依次对应了用户接口层、业务逻辑层与数据服务层。它的显著优势就是：**结构足够简单，不管业务简单还是业务复杂的系统都能往上套**。因为本质上它的分层思想是工程化分包思想，而不是业务化分包思想。

**为了将纯工程化思想转化为业务驱动架构思想，DDD 提出了六边形架构来解决日益庞大的系统维护困难的问题。**

但是 DDD 也不是一口气就提出了六边形架构，准确地说 DDD 的架构分层模型不止六边形架构这一种。DDD 的架构在市面上被说到比较多的就是四层架构、五层架构与六边形架构。

那么为什么最终我们在使用 DDD 的时候，基本上都是选择六边形架构而不是四层架构或者五层架构呢？下面以四层架构为例给大家阐述其中的演变过程。

还记得战略设计中 MVC 直接映射 DDD 分层的这张图吗？

![image-20210913185730992.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/ee477b5e0e5b45598a3542bd7f8ab10a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

它的分层思想依赖关系即符合了 DDD 的在战术设计上的分层，又跟 MVC 的分层极为类似。从上往下，用户接口层对应了 MVC 中的 Controller 层，MVC 中的 Service 层被拆分成了应用层（用于编排逻辑）和领域层（实际业务逻辑编写），最底层的基础设施层对应了 MVC 中的 Dao 层。

乍一看，这个分层思想好像很合理，与 MVC 的分层思想不冲突，而且我们也能按照 DDD 的思想去开展业务。但是我们从层级依赖上来看一下，上层依赖下层。在 MVC 的分层下，我们通常会认为越在下面的层，它距离实际的功能点的逻辑是越来越远的。也就是说一些通用的工具类、系统配置、消息发送接收配置、外部接口调用封装等通用型的功能都会被集中定义到基础设施层中。而这时，领域层却依赖了基础设置层，让本应该纯粹只处理限界上下内文的领域受到了外部服务或者一些配置的污染。而且我相信一旦有了基础设施这样一个大杂烩层之后，总会有那么几个人，把一些本应该放在领域里面的逻辑定义在了基础设施里面，逐渐你的架构就又开始退化。

为了解决这个问题，世界级编程大师 Robert C. Martin 提出了改进四层架构的思想：**依赖倒置**。他认为：

> 高层模块不应该依赖于底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

怎么来理解上面的这段话呢？

在四层架构的世界中，上级需要做什么事情都是需要下级实际拥有这个能力，上级直接调用才能完成。而依赖倒置之后，只要下级定义了能力的接口，上级就可以通过依赖注入的方式来直接注入接口，调用接口方法即可。而下级对应的接口逻辑实现，被放置在基础设施层，提到了最上层，如下图所示：

![image-20210913190943631.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/84af70c46d894fd69c16eab628dd6b13~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这就是所谓的六边形架构，如下图所示：

![1595145053324-34eb42e7-5ff1-469a-855c-bcd144dcfa26.jpeg](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/693069fc897246d384e5f16dd1a89ea8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

从外往里看，领域模型（对应领域层）完全独立，可以自由地开展自己的业务。应用服务包含了领域服务进行逻辑编排，完成功能点的业务组装。并且应用服务作为业务系统的统一门面，提供各种适配的接口给外部来访问。

## 二、传统分层架构

理论说了这么多，到底代码结构是怎么样呢？分层又是怎么分的呢？

我最初在落地六边形架构的时候，使用的是传统的 DDD 代码分层方式，即在 Spring 的项目中，Maven 的模块依赖 Infrastructure Module依赖Application Module，Application Module依赖了Domain Module。项目结构如下图所示

![image-20211212220158773.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/4fc10f4caa424f1686aee7ea70f1f7ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这里分别介绍一下这几层的含义。

**Infrastructure（基础设施层）：** 提供系统运转的非业务逻辑的基础能力，支撑系统运转。

**User Interface（用户接口层）：** 我们平等地认为 Controller、RPC、MQ 等都属于外部用户输入，放置在用户接口层。

需要说明的是，这里没有按照依赖倒置图把用户接口层放在基础设施层的下面，我觉得用户接口层已经是外部的输入了，里面是请求转发至应用服务层，逻辑定义非常薄。没必要为了形式而把接口定义在用户接口层，把逻辑放在基础设施层。

**Application（应用服务层）：** 编排领域层业务逻辑、参数校验、事务控制等。

**Domain（领域层）：** 核心领域层，定义与领域相关的一切内容，包括聚合根、实体、值对象等。

## 三、灰度分层架构

传统的分层架构在大多数业务场景下是没有问题的。但在实际业务中，领域层的领域服务为了完成原子化的业务逻辑难免会依赖应用服务。为了保证领域层足够纯粹，增加了 **Interface（灰度层）** 这一层，在里面定义了领域层需要调用依赖的接口，在基础设施中去实现调用应用服务。

**这一层应用服务与领域服务都可以调用。Interface 层在标准的 DDD 代码分层中是没有的，是为了应对特别复杂的业务流程而增加的。**

代码分层如下：

![image-20211212220848456.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/7ee2dbcf34834aa5a49000a15c3d87e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这样分层之后，系统处理外部请求的流程就变成了如下图所示的情形：

![未命名文件.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/02c387ba520a4fd295ef55df61d37f96~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

从流程图调用上来看好像没有什么问题，非常符合 DDD 的六边形架构思想。如果共同维护系统的小伙伴对于业务的认知高度一致，且对 DDD 的分层思想了解得比较清楚的情况下，这种方式非常好，`进可攻退可守`。

不过实际情况中，很有可能某个逻辑都不需要领域服务介入，但是因为 Interface 是灰度层，里面什么都能放，它可以把大量的业务逻辑都定义在 Interface 层处理。久而久之，Interface 层的逻辑会迭代得越来越多，退化成了 Service。

## 四、能力分层架构

我们重新来思考一下传统六边形架构在应对复杂业务场景时可能会出现的逻辑混乱问题：Interface 层是为了解决领域服务在处理原子化逻辑的时候，可能出现依赖其他应用服务或者领域服务能力的情况，但是它又可能导致代码混乱的问题，看上去好像发生死锁了。

我们跳出来看一下这个问题，本质上 Interface 层的存在是为了解决领域服务处理原子化逻辑时对外部的依赖问题。那么我们是不是解决掉这个原子化逻辑定义的位置就好了呢？

在前面“DDD的战术设计”那节课中我们提到过，大多数情况下，领域服务是不可能存在的。它存在的场景是为了包装一个多领域协作的单领域原子化逻辑，如果放在应用服务中，好几行逻辑调用不能突出原子化。

我们在编写 MVC 架构下 Service 的代码时，为了包装一个显著的逻辑我们的方式是什么，**定义一个私有的方法对不对**？

那在 DDD 里面是不是也是可以这么做呢？

显然是可以的，我们可以定义一个私有方法去包装这个原子化逻辑，主方法的逻辑就很清晰。

那么问题来了，这段逻辑如果其他的应用服务也需要使用呢？有人会说把私有方法变成公有方法开放出去。

应用服务是什么？整个系统对外提供的功能点出入口，你的这个逻辑只能被系统内部所使用，外部根本用不到。违背了应用服务层的对外定义。

所以，为了防止这段逻辑，我们定义了一个中间层——能力层。它介于领域层与应用层之间，用于表达原子化的领域逻辑，它的编码规范与应用服务一致，即只能编排逻辑。

这样，我们的架构就变成了下图这样：

![image-20211212204414303.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/6ba0be6d6a1d4f278c01f901faace32b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

比如，我现在要实现新建用户这个需求。可以有两种方式：一种是直接在应用服务内编排完你的新建用户逻辑；另外一种就是定义一个新建用户的能力层，A 应用服务可以调用这个能力层完成用户新建，B 应用服务也可以调用能力层完成用户新建。

能力层的调用与被调关系如下图所示：

![image.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/7ef29eaa135f4175817673aeb4c7196c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

每层的调用关系为：

- 强制：应用服务编排能力层与聚合逻辑；
- 强制：能力层编排能力层与聚合逻辑；
- 建议：应用服务之间不互相调用；
- 强制：能力层之间可以互相调用；
- 强制：能力层不调用应用服务层。

## 五、总结

本文从 MVC 的三层架构出发介绍了六边形架构的演变过程，并且说明了六边形架构通过依赖倒置来纯粹化领域层依赖。另外，还分别介绍了传统分层架构、灰度分层架构与能力分层架构在不同业务场景与实际应用场景下优缺点。

最后如果你问我，是不是能力分层架构是最好的？我的答案肯定是**否定**的。

从灰度分层架构和能力分层架构它们的分层图就能看出来，这两种分层的区别点就在于 Interface 层与能力层。而我也说了领域模型设计合理，业务边界足够清晰的情况下，是不会出现领域服务的。也就是说 Interface 层与能力层都可以去除，这就变成了传统分层架构。

灰度分层架构相比较能力分层架构在领域模型使用上的灵活性更强，如果团队成员对 DDD 理解深刻、业务理解够好，我更建议这种。

能力分层架构在层与层之间的职责分割上更加明确，并且能力层还能扩展出其他的一些前置处理（将在后续的文章中讲述）。对于成员较多、DDD 理解不是特别深刻的团队而言，这种强结构化分层架构更加合适。
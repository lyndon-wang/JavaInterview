# 11、如何落地防腐思想？

我们一直在小册中强调DDD的内聚与解耦的核心思想。那么DDD中除了划分好各自的限界少下文，建立领域模型，还有什么操作是用来解耦的吗？比如，在前面“DDD的战略设计”的上下文映射图中的防腐层就是DDD的解耦思想的一种体现。

**不同限界上下文之间的协作通过防腐的思想来独立各自领域的逻辑。**

本文将以防腐为核心，为你讲解 DDD 中如何来落地防腐思想。

## 一、防腐是什么

早在本文之前，我们就已经接触到了 DDD 中的防腐思想。

《分层详解：如何明确各层级的使用场景与方式》一文中，我们通过建立领域服务、Interface、能力层的形式来防止为了完成原子化的业务逻辑而导致外部领域逻辑入侵值本领域逻辑。应用服务层我们通过Command的to方法或者工厂类的形式防腐外部参数变化对于业务层组装聚合的逻辑侵入。

《事件驱动模型踩坑实践》一文中，我们通过建立事件驱动模型来隔离应用服务在编排功能点时，屏蔽了非当前功能点核心逻辑与外部功能点逻辑的耦合。

《仓储落地：串联数据模型与领域模型的桥梁》一文中，我们通过构建仓储层的形式来隔绝了领域模型与数据模型的之间耦合。让领域模型可以自由地根据自己的业务边界进行逻辑处理，而不用考虑领域模型的存储方式与存储介质。

那么根据上面的一些概念与操作，如何对防腐下一个定义呢？

**不同限界上下文之间如果需要进行业务往来，它们并不会直接通过 RPC 等方式进行通信，而是通过一个中间方或者一个约定好的规则来进行互相通信。上下文映射图中的开放主机服务、发布语言以及防腐层就是防腐思想的体现。**

## 二、外部系统的防腐

前面几篇文章中我们所提及的那些防腐手段都是主要针对系统内不同限界上下文之间的。系统内业务边界的可控性是比较高的，因为这个系统是当前团队维护的，一旦出现了突破业务边界的操作，我们可以立马进行代码调整。

**但是如果我们在应用服务编排业务逻辑需要外部服务所提供的能力呢？**

本系统我们使用DDD进行了开发，业务边界隔离清晰，接口很规范。但是我们无法控制外部服务的开发框架。比如，我们现在需要依赖单位管理的服务来获取单位信息，微服务体系下，我们通常是使用RPC进行通信的。

代码示例如下：

```less
@Autowired
UnitApi unitApi;

@Override
@Transactional(rollbackFor = Exception.class)
public void create(CreateUserCommand command){
    
    //省略不必要的逻辑
    
    UnitDTO unit = unitApi.getByUnitId(command.getUnitId());
    log.info(unit.getName());
    
    //省略不必要的逻辑
}
```

我们在MVC微服务体系下使用RPC都是这么个操作：Service中直接调用单位服务RPC接口。

这段代码乍一看没什么问题，但是你碰到过这种情况没有？

单位服务作为上游系统业务逻辑变动，导致了接口方法或者出入参修改。这时对于下游系统来说，我们对应依赖用户服务的接口都需要进行更换，出入参都需要进行调整。这个方法引用到的地方少还好说，如果是基础信息获取接口，方法逻辑散落在各个应用服务中。那么我想，上游研发人员通知你要修改的时候，你一定想给他邦邦来两拳，最后再苦逼哈哈地一个个关联点去修改。

**我们梳理一下思路，出现这个问题归根到底的原因有两个。**

1. 上游服务接口逻辑变动，破坏了规约；
2. 本系统过分信任上游服务接口，将接口调用逻辑散落在系统各处。

只要破坏上述任意一个条件我们就能避免逻辑依赖的问题。

1. **在上游做文章**。最简单的方式就是上游系统兼容历史版本接口，这个是一般上游服务开发团队都会遵守的规约。但是这种限制是人为约定的，Spring这种框架在版本迭代的过程中都有可能变换一些API的使用方式，更别说上游业务团队的系统了。并且我们现在依赖的是单位服务的能力，如果后续大的业务架构调整，没有了单位服务，变成了中台。不可能让中台提供这样强业务属性的接口，所以换汤不换药，本质上本系统还是存在这个隐患。
2. **在本系统做文章**。信别人不如信自己。下游出现问题后维护困难的原因在于接口逻辑散落在的各个应用服务层。

那么我们是不是可以把这个调用方规整到一起呢？找一个中间方去调用上游系统接口，系统内依赖中间方就好了。如果上游接口变化或者提供能力的服务变化，我们也只需要修改中间方就好了。

在本系统中这种做文章的方式我们称为`防腐层`。

我们认为一切外部服务所提供的能力或者模型都是不可靠的，我们如果要去使用这个能力，应该依赖本系统内的适配能力接口，由接口实现类去依赖外部服务与模型。

这样我们的供求关系就从`别人有什么我们就用什么`变成了`我们用什么别人提供什么`，如下图所示：

![image-20211216124013521.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-10/1c89b75d2ccd40dab7cb956d1e76c92b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

## 三、落地防腐层

**防腐层又称适配层，用于转义内部上下文依赖的外部上下文。**

那么在DDD中我们如何去落地呢？

上面说到系统内对于外部服务的依赖通过接口的方式，为什么通过接口？因为接口是一种抽象规范，这跟DDD的分层思想是一致的，我们应该依赖抽象，由抽象去依赖细节。

**这个防腐的接口应该放在哪一层呢？**

首先，肯定不是基础设施层，它是基础能力提供方，放的应该是防腐接口的实现。

那应该放在应用层还是领域层呢？

我习惯与把防腐层的接口看成公共的能力提供方，它们不是什么特定的外部服务提供的逻辑，而是系统内为了完成功能点逻辑本身就存在的基础能力。

**那么，基础能力的接口应该被定义在哪里呢？肯定是领域层了。**

下面我们来看一下**新建用户关联单位服务提供的单位信息**逻辑的防腐代码示例。

**1. 在领域层定义防腐接口**

```php
/**
 * 单位适配器
 *
 * @author baiyan
 */
public interface UnitAdapter extends Adapter {

    /**
     * 根据单位id获取单位信息
     *
     * @param unitId
     * @return
     */
    UnitDTO byUnitId(Long unitId);
}
```

注意此处的UnitDTO并非单位服务RPC的返回数据结构，而是系统内根据业务逻辑定义的我们所需要的数据结构。

**2. 在基础设施层定义防腐接口实现类**

```java
@Component
public class UnitAdapterImpl implements UnitAdapter {

    @Autowired
    private UnitApi unitApi;

    @Override
    public UnitDTO byUnitId(Long unitId){
        //调用单位服务获取单位信息，返回字段假设有10个
        UnitInfoDTO byUnitId = UnitApi.getByUnitId(unitId);
        ValidationUtil.isTrue(Objects.nonNull(byUnitId),"unit.is.not.exist");
        //只需要三个字段
        UnitDTO unitDTO = new UnitDTO();
        //仅做三个字段的映射
        BeanUtils.copyProperties(byUnitId,unitDTO);
        return unitDTO;
    }
}
```

在基础设施中实现防腐接口，对于外部服务提供的接口能力做适配，仅取我们自己所要的几个字段。后续哪怕外部服务接口变更，甚至服务变更，都只需要修改此处逻辑即可。

**3. 应用服务使用**

```less
@Autowired
UnitAdapter UnitAdapter;

@Override
@Transactional(rollbackFor = Exception.class)
public void create(CreateUserCommand command){
    
    //省略不必要的逻辑
    
    UnitDTO unit = UnitAdapter.byUnitId(command.getUnitId());
    log.info(unit.getName());
    
    //省略不必要的逻辑
}
```

应用服务依赖抽象，收缩了散落在系统各处的 RPC 逻辑。

## 四、拓展防腐/适配的思想

除了RPC的上游服务依赖以外，类似于HTTP接口、ES的Template接口等外部依赖都需要进行防腐。因为本质上它们是提供了数据或者能力协助当前系统完成逻辑编排。

到现在我们已经知道了外部服务依赖可以用防腐层，内部逻辑依赖可以通过领域服务、仓储等战术设计来防腐。

**那内部逻辑有需要使用防腐层的地方吗？**

不用想，既然问了，那肯定是有啦。

这里我举个业务场景，结合小册的学习，你觉得应该如何划分。

有一个业务系统，系统中有N个领域模型，它们分别对应着M个数据模型。这个业务系统在A地有一套环境已经部署，现在需要从A地迁移数据并全量覆盖至B地的业务系统。我们假设 A、B 两地系统版本一致，数据库表结构一致。

**如果把上述的需求做成一个功能，你会如何去设计呢？**

这个是我所负责的系统里面的一个业务需求，最开始因为我们是通过MVC写的，所以写逻辑的时候一股脑地塞到Service中就好了。但是后续我们进行了框架升级，从MVC升级至DDD，发现迁移这个逻辑好像突破了限界上下文。

我们来看M个数据模型对应这N个领域模型，数据模型的数据变动仅能通过领域模型的逻辑处理后调用仓储变更。如果按照标准DDD的做法，我应该在上游组合领域模型传给下游，下游迁移服务分别调用应用服务保存领域模型。但是这么做的后果就是，我本身只想要做数据迁移的，中间却要走一大堆的业务逻辑转换，还特别容易出错。

但是如果我们上游直接提供表数据，下游直接在应用服务插入表数据又不符合数据是随着领域模型变化而变化的边界。

我们再来梳理一下这个逻辑，到目前为止我们一直认为迁移是业务逻辑行为，也就是说迁移表数据这个动作我们定义在迁移的业务逻辑里面。**如果我们跳出来看，被迁移的数据是不需要逻辑关联的，并且上级数据全量覆盖下级数据。那我们是不是可以认为迁移只是一层壳，实际迁移的动作是由系统的底层能力所提供的，我们仅仅只是调用了这个能力呢？**

```
合理，相当合理！
```

**防腐层不就是底层能力提供方之一吗？**

我们定义一个迁移数据的适配器，将待迁移的表数据传给适配器，适配器内部去一个个调用Dao层直接插表就完成这个迁移的逻辑了。

示例代码如下：

```java
public interface MigrationAdapter extends Adapter {

    /**
     * 数据迁移能力
     *
     * @param data
     */
    void doDataMigration(String data);
}

public class MigrationAdapterImpl implements MigrationAdapter {

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void doDataMigration(String dataString){
        DascaMigrationDataDTO data = GsonUtil.gsonToBean(dataString,MigrationDataDTO.class);
        List<Data1PO> data1 = data.getData1();
        List<Data2PO> data2 = data.getData2();
        // 清空全量表
        this.emptyData()
        //入库
        dataMapper1.insertBatch(data1);
        dataMapper2.insertBatch(data2);
        log.info("数据迁移完成");
    }
}
```

迁移的应用服务调用该适配器的 **doDataMigration** 方法即可。

## 五、总结

本文从DDD在战略设计与战术设计中的概念出发介绍了防腐思想的概念。但这都是系统内部架构上的防腐，外部服务与外部能力的防腐我们由专门的防腐层来包装依赖，将供求关系从`别人有什么我们就用什么`变成了`我们用什么别人提供什么`。最后我们还通过了一个业务场景来拓展了防腐层的更多应用场景。

如何用好DDD对内、对外的防腐手段与防腐思想，这对系统的解耦与业务逻辑的内聚很重要。
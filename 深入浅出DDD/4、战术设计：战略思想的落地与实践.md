# 战术设计：战略思想的落地与实践

上一节我们学习了 DDD 在应对大型应用系统时的战略设计，但是仅仅停留在架构设计的理论层面去拆分与设计。本文我将介绍 DDD 的战术设计，让你明白 DDD 如何在代码设计上与切合它的战略设计。

我们先来回顾一下 DDD 的战略设计包含了什么：领域、子域、限界上下文、通用语言、上下文映射图和架构风格。战术设计为了匹配战略设计主要包括以下概念：**聚合、聚合根、实体、值对象、应用服务、领域服务、仓储、事件模型等。**

## 一、聚合、聚合根、实体与值对象

领域/子域是 DDD 战略设计中最核心的业务体现。那么对应到代码层面，领域/子域的概念的呈现方式是什么呢？答案是：`聚合`。为了描述聚合内部的属性，DDD 定义了实体与值对象的概念。最后，领域的逻辑呈现要在一个限界上下文中才有意义，必然要有一个概念来包括下领域的逻辑与定义业务的边界，这个就是`聚合根`。

### 1. 实体

实体是描述某一可连续变化的物体。它是具有生命周期的，并且可以通过唯一标识来确定是否为同一个实体。

比如，现在有两个长相一模一样的双胞胎分别叫张三与张四。他们是独立的个体，大家不会因为他们长得一样而认为他们是同一个人。他们刚出生的时候什么都不会，随着年纪的增长，张三成为了科学家，张四成为了企业家。但是他们并不会因为各自的身份属性变更，而导致他们不是张三与张四了，因为本质上他们这个人的唯一标识在成长过程中一直未改变。

**实体 = 唯一标识 + 生命周期（可以理解为属性可变）**

### 2. 值对象

`它与实体定位正好相反`，如果一个物体一旦被生成之后就具备不可变性，并且只要它们的属性值一致就可以认为它们是同一个物体。

比如，双十一我们在淘宝购买商品的订单，订单中会包含地址，地址就是典型的值对象。只要省、市、区与详细地址一致，就判断它是同一个地址，并且这个地址一旦确认下来之后就不会产生属性的变更。

等等，好像不对，我下的订单明明可以修改地址啊，这不是可变的吗？

这里很容易进入一个误区，我们认为修改地址是在原有的地址上进行的修改，但实际我们是给了一个新的地址直接去替换的原来的地址。**如果需要对值对象作出修改，那就整体替换。**

**值对象 = 不变性 + 通过属性判断相等（没有唯一标识）**

### 3. 聚合

它是`领域的抽象体现`，包含了当前领域内的一切事务。它在代码层面主要呈现的方式是模块的划分。

比如下图，我定义了一个用户领域，那么我会划分出一个用户的聚合包，把专属于用户领域的内容放在 **com.baiyan.ddd.domain.aggregate.user** 这个包下。

![image-20211211191605584.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/bfdc8a16e73b422f854fe3529b0bed09~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### 4. 聚合根

如果说聚合是领域的抽象体现，那么聚合根就是`领域的具象体现`，它是一种特殊的实体。聚合根内部定义了当前领域需要的业务属性（实体与值对象），并且包含了该领域内所有的业务逻辑定义。

比如订单这个领域，它的具象体现就是订单聚合根。订单聚合根内部包括了订单明细实体、地址值对象等各种属性。在订单聚合根内部定义了订单领域的业务逻辑方法。

**聚合根 = 领域强关联的实体、值对象 + 核心业务逻辑**

### 5. 实体、值对象与聚合根的关系

到这里为止，我想你应该明白了实体、值对象、聚合根的概念了。那它们之间的关系是什么呢？

**第一个，包含关系**。如下图所示，聚合根内部能够包含 N 个实体与 N 个值对象，它们作为聚合根的属性。

![image-20211211193302296.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/9c21d66e56064ab0adc6ecbcdaf8bb1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

**第二个，生命周期关系**。这个从包含角度其实就很明显，聚合根里面包含了实体与值对象。也就是说实体的生命周期是捆绑着聚合根的，由聚合根来维护。而值对象不存在生命周期，只能被整体替换。

**第三个，标识关系**。聚合根本身就是实体，它的 ID 就是它的唯一标识，这个没什么好说的。但是实体的唯一标识是仅针对当前聚合根而言的，就像商品实体能够被订单聚合关联，也能被物流聚合关联。值对象在聚合内部的唯一性通过`属性相等`判断实现。

### 6. 建立实体、值对象与聚合根关联

明白了以上的概念后，在领域建模过程中怎么来划分实体、值对象与聚合根呢？

这里我们以**新建用户，新建过程中需要给赋予角色**这个需求为例，给你讲解这个划分思路。

首先针对这个需求你有没有一点疑惑，觉得这个需求好像不是很清楚。

对，这里没有说出角色能不能独立开展业务，是否有独立的生命周期。随着这个思路，我们分别根据角色的不同定位来划分一下这里的关联关系。

**角色非独立维护**

整个系统中的角色不是独立开展的业务，比如我们定义了一个角色的枚举类，系统的用户只能关联这个枚举类对应的角色。这个时候，角色在用户聚合根内就是值对象，因为此时角色满足了不变性与属性判断相等这两个条件。

示例代码如下：

```php
/**
 * 用户聚合根
 *
 * @author baiyan
 */
public class User implements AggregateRoot {

    /**
     * 用户id
     */
    private Long id;

    //省略非关键属性

    /**
     * 角色值对象
     */
    private List<Role> roles;

  
    //省略业务逻辑方法

}

/**
 * 角色值对象
 * @author baiyan
 */
public class Role implements ValueObject<Role> {

    /**
     * 角色code
     */
    private String code;
    
     /**
     * 角色名称
     */
    private String name;
    
    /**
     * 比较角色相等
     *
     * @param role 角色
     * @return
     */
    @Override
    public boolean sameValueAs(Role role){
        return Objects.equals(this,role);
    }
}
```

**角色独立维护**

如果角色本身可以独立开展业务，比如系统内管理员可以新增自定义角色，新增用户的时候可以关联到这个角色。超级管理员可以修改角色的名称，此时查看用户关联角色信息时应该是修改后的角色名。

很明显，这种情况下，角色本身在用户聚合根内是一个可以变的状态，并且如果用户需要感知到角色的可变，只能通过角色的不可变的唯一标识去感知。这种情况下，角色在用户内就是实体。

示例代码如下：

```php
/**
 * 用户聚合根
 *
 * @author baiyan
 */
public class User implements AggregateRoot {

    /**
     * 用户id
     */
    private Long id;

    //省略非关键属性

    /**
     * 角色实体，这里也可以直接是
     * private List<Long> roleIds;
     * 包装成POJO，业务语义更强，表示这是实体，区分于本身领域内部的基础业务字段
     */
    private List<Role> roles;

  
    //省略业务逻辑方法

}

/**
 * 角色实体
 * @author baiyan
 */
public class Role implements Entity {

    /**
     * 角色id
     */
    private Long id;
}

```

## 二、应用服务与领域服务

根据划分后的领域，我们能够确定领域的具象体现——聚合根。此时，原子化的业务逻辑都被定义在了聚合根内部，这也是 DDD 所推崇的**解耦与内聚思想**。一个聚合根只代表了一个领域的业务，而我们系统的功能体现往往是多个领域聚合协作的，对应了战略设计里面的上下文协作。

为了完成这种协作逻辑，战术设计中定义了应用服务层与领域服务层。

### 1. 应用服务

应用服务可以看作是一个`流程编排引擎`，它本身不承担任何业务逻辑处理。应用服务可以理解为功能用例层，比如新建用户，这个功能就应该定义在应用服务层。但是新建用户是一个比较繁琐的流程，比如涉及到关联角色等业务逻辑处理。这些业务逻辑处理应该被定义在用户聚合根内部，而应用服务只负责调用定义在聚合根内部的方法就好了，屏蔽的业务逻辑的具体实现。

应用服务表象定位与 MVC 中的 Service 比较像，但是 Service 内部充满了功能点的逻辑处理，而应用服务相对来说是比较薄的一层，它只做逻辑编排。参数校验、聚合根方法调用、外部服务调用、持久化聚合根等与业务流程走向相关，业务逻辑无关的代码均可定义在此处。

应用服务是整个系统的门面，也是**六边形架构中的出入口**，外部服务通过访问应用服务提供的接口来执行功能用例。

### 2. 领域服务

虽然应用服务与聚合根逻辑几乎已经覆盖了功能点的实现，但是有时还是会出现这样的业务场景：

**A 聚合根需要做一个原子化的逻辑处理，但是这个逻辑处理需要 B 聚合根的逻辑协作才能完成。**

这种场景的实现方式有两种。

第一种就是在应用服务内先调用 A 聚合处理一下，再调用 B 聚合处理一下，最后再调用 A 聚合收尾逻辑。这种方式符合 DDD 思想，但是对应到应用服务，我明明是一个很原子化的 A 聚合的逻辑处理，居然有三行代码。而这段逻辑会被好几个功能点调用，每次为了完成这个逻辑我就要写三行代码，显然逻辑的原子化不够突出，还容易出 Bug。

第二种就是应用服务与聚合根都各退一步，在它们中间抽象一层领域服务。把 A、B 聚合协作逻辑定义到 A 的领域服务内，应用服务调用 A 领域服务即可，这样在应用服务上看这段逻辑就很清晰了。

领域服务其实是对业务的一种妥协，`理想情况下是没有领域服务的`。一旦出现了领域服务，一定要确定好这是否在执行一个特别显著的、专属于某个领域的原子化业务逻辑。滥用领域服务很有可能会演化为逻辑又定义在 Service 状况。

## 三、仓储

我们知道为了内聚业务逻辑，应用服务层编排的都是聚合根的业务逻辑，也就是说我们一直在应用服务内操作的都是领域模型。但是领域模型是针对于业务层面的，而领域模型处理完业务之后需要通过数据层存储。数据层对应的是数据模型，**为了桥接数据模型与领域模型，DDD 在战术设计中提出了仓储的概念**。

仓储的定位就是**持久化聚合与检索聚合**。让应用服务专注逻辑编排，聚合根专注逻辑处理，不用关心领域模型的持久化方式与存储介质。

## 四、事件模型

虽然按照上述的方式我们已经可以在战术上切合战略设计，但是貌似应用服务为了完成一个功能要做一些都不是这个功能点的事情。

比如下订单后，给用户增长积分与赠送优惠券的需求。如果在应用服务内实现，用户逻辑处理完，数据入库成功后，再依次调用用户增长积分的外部服务接口与赠送优惠券的外部服务接口。

到这里是不是很奇怪？我一个订单领域，已经把下订单这个事情做完了，但是却还要调用其他的三方服务的接口通知它们订单生成这个事情。如果后续通知的接口越来越多，对于应用服务简直就是灾难。

为了解决这个耦合严重的鸡肋点，DDD 的战术设计中提出了**事件模型**。下单完成后，发布一个下单完成的领域事件，让需要感知这个事件的服务自行监听并处理，忽略不相关的领域活动。

领域事件的发送成功应该与功能点的事务是一致的，但是领域事件的处理结果不应该与功能点事务一致。

我下订单成功了，发送了创建订单事件，但是积分增长失败了，这时如果让订单生成失败，这显然是不合理的。

## 五、总结

本文通过对比 DDD 的战略设计层层递进介绍了 DDD 如何通过战术设计建立起一个解耦与内聚的系统。

从`领域设计`出发介绍了聚合、聚合根、实体、值对象的概念，并且通过一个理解讲解了聚合根、实体、值对象三者的关系。明白了在进行建模时要根据实际业务出发来划分聚合根内的实体与值对象。

从`上下文协作`出发介绍了应用服务如何协作不同的聚合根完成功能点的定义，并且为了让业务的体现更加原子化引入的领域服务。当然，领域服务虽香，但可不要乱用哦。

最后介绍了使用仓储来屏蔽领域模型与数据模型的转化，使用事件模型来解除与不相关领域活动的耦合。这两步从严格意义上来说都是`为了解耦`。

同样，在这一讲的学习过程中，如果你遇到什么问题或者有好的经验要分享，欢迎你在留言区与我分享，我们一起交流，一起进步。
# 10、如何落地 CQRS？

在前面“DDD的仓储落地”中，我们知道增删改这种指令性操作走DDD的领域建模，而查询我们就直接走CQRS模型。

在前面“事件驱动模型踩坑实践”中，我们知道了如何在DDD的使用Spring的事件监听机制搭建事件驱动模型，并且知道了在DDD中应用时的坑点。

本文将基于以上两个知识点给你介绍在DDD中到底如何落地CQRS模型，以及事件驱动模型在CQRS中又能起到什么样的作用。

## 一、CQRS 是个啥

在介绍CQRS之前，我们先来看看MVC分层下，一个前端请求从进入后端到处理完成返回前端的过程是什么样的。

如下图所示：

![image-20211215141202500.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-10/871ce3feca6f4f94a6f5992f226600a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

- **接受请求**。后端的Controller接口接受来自于前端传递的Request-DTO（Data Transfer Object）实体请求参数，Controller将Request-DTO传递给Service层做业务处理，Service层解析Request-DTO拆分成DO（Data Object）转给Dao层，Dao层与DB使用DO进行交互。
- **返回请求**。Dao层从DB取到的数据使用DO进行包装，再返回给Service层进行业务逻辑处理，Service层将处理后的DO包装的Return-DTO返回给Controller，最后返回给请求方。

我相信只要你在使用MVC，除了极少数“大佬”使用Map或者Json走天下以外，基本上你都是这套数据传递方式用来处理前后端请求交互。

**为什么大家会选择这种方式呢？因为偷懒是人的本性。**

比如，我们做后端管理系统的时候，报表展示的字段往往跟报表新增的字段是非常类似的。偷懒一下，我们常常会将Request-DTO与Return-DTO定义成同一个DTO。而如果说它们之间有字段差异了，就缝缝补补加字段上去。

这样做会有以下三个“**致命伤**”。

1. Request-DTO与Return-DTO由于字段被混合定义，如果我们要修改一个字段，找到这个字段的影响点往往特别费劲。
2. 我们从把DO拷贝给时，经常做的操作就是BeanUtils.copyProperties，特别容易在接口层面返回过多的字段给前端，造成数据泄漏。
3. DTO本身直接是数据传输，承担的是固定的业务数据装载。现在因为职责的模糊化，在业务代码中我们无法直接根据DTO知道业务数据的具体作用是什么，需要结合代码的上下文来理解，增加了系统的复杂度。

出现上面问题的本质原因就是：`DTO 太万能了`。我们应该把这两者区分开来，如下图所示：

![image-20211215141718995.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-10/d3f35e90d518404dbf78bcd0793bbd70~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这张图分为上、下两个部分，增删改会修改DB数据的命令我们称为指令性查询，通过Command类型命令参数传递进来，层层处理并入库。查询是幂等操作，我们通过Query类型的查询参数一层层传递进去，在DB接受请求后返回DO数据，然后再Service层包装成Return-DTO返回。

这样，增删改查的入参都有了各自对应的参数类型，返回的数据结果由DTO来装载。不仅从名称上一眼就能看出来的作用，在使用上也不会互相混淆字段，将字段修改对业务的影响从设计层面降到最低。

上面这种操作就是CQRS，英文全称 Command Query Responsibility Segregation，翻译过来就是**命令查询职责分离**。

## 二、事件溯源

上面我们已经把查询与命令的职责分离了，但是为了追求更高的性能，我们经常会通过分库的形式将数据库分为读库与写库。这种分库操作比如MySQL其实已经有现成的方案做了支撑。但是还有一种情况，比如我们需要对数据进行溯源，保证数据的高性能的同时，还要能够各种维度查看数据。

比如，我们都在用的支付宝与微信，它就是比较典型的可溯源的系统。你的每一笔出账，入账都会被记录在账单中，你最终账户的余额就是根据这些账单溯源计算得到，你也能通过账单查看某一个节点的数据状态。

**那么，这种事件溯源的分库方式是怎么样的呢？**

我们来看一下下面这张图：

![image-20211215150553873.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-10/6238de621d8a4e568f804a39cb9e9229~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

增删改的Command写入DB的同时发送事件给事件处理器，然后事件处理同将事件写入读库，由读库对事件进行溯源生成查询所需的视图。

现在我们不仅能在读库中看到每一笔账单数据，也能在读库中基于账单数据作出各种（比如 2021）个人消费统计等视图。

**事件溯源给我们带来了这样的好处：**

1. 将命令与查询的压力分在了不同的库中；
2. 业务可溯源，可重现，对于追踪与修复某个时间点的 Bug 非常友好；
3. 由于事件溯源记录了业务的迭代过程，因此如果我们要做库的扩展，直接重放事件即可。

**当然它也不是万能的，也有不少的缺点与限制。**

1. 读库与写库之间的结构维护又是一个繁琐的事情，通常都是业务侧提供数据，大数据部门来对业务数据进行解析规整。这种情况下，本身内部的事件字段却与外部的团队产生了耦合，免不了跨团队扯皮。
2. 事件一定要做好幂等处理。业务方如果发送出去的数据一旦产生了重复或者丢失，那么最终的溯源结果一定会受到影响。
3. 事件溯源对于复杂的视图一般是异步计算的，保证的是数据最终一致性，对于实时性高的计算逻辑，还是直接走写库或者直接走常规的分库分表模式。

## 三、DDD中的应用

讲了CQRS跟事件溯源的基本概念，那么在DDD中到底怎么应用呢？跟文章开头所说的事件驱动模型又有什么关系呢？看官别急，且往后看。

还记得我们在“事件驱动模型踩坑实践”那篇文章中说过：**聚合的命令性操作理论上都应该发布领域事件并存储，便于逻辑扩展与后续事件溯源。**

DDD天然就适配了事件溯源，所以我们只需要做好CQRS就好了。

我们来看看DDD中CQRS与事件溯源结合的流程图：

![image-20211215154204978.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-10/265d611fc03f466dbd706d58584ca5b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

增删改指令走DDD的领域建模模式进行业务逻辑处理，逻辑处理结束后先写仓储，再进行事件处理。这里的事件处理包括本身对于事件的外部领域业务逻辑处理与**写入事件至读库**（也可以不写，详看后文）。查询命令我这里直接通过查询的应用服务**访问读DB或者写DB**。

```
这张图你有没有发现一点奇怪的地方？不是说读写分离分库吗？为什么查询还去查了写库。
```

还是从事件溯源的角度出发，事件溯源最终的目的是让我们能够更好地去查询数据，减轻复杂查询对于写DB的压力。但其实大多数情况下，系统页面对于查询的需求仅仅只是数据模型的简单组合而已，并没有那么多系统像支付宝的账单一样需要进行溯源，生成复杂的年度统计视图等。因此我在查询应用服务还标了一根线直接查询写DB。

然后我们再来看看EventHandler写入事件至读DB那里，你有没有想过我们现在假设的所有场景都是基于事件是所有应用服务逻辑处理完成之后才发送的。

**那有没有可能业务逻辑执行到一半要一次事件，执行到结束又要发一次事件的逻辑呢？有！**

比如我们做一个迁移的逻辑，一共分为两步：迁移数据与迁移应用。我在数据迁移成功后应该发送一个事件出来表示数据迁移完成了，但是后续迁移应用失败了。此时因为事件的事务与主流程是独立的，迁移数据成功的事件已经入库。后续再次发起迁移后，迁移事件又会被发送一次。但是我的业务需求是这个迁移事件已经仅保存一次，这就涉及到了事件幂等。

上面说的是主流程失败的情况，那事件处理失败的情况呢？比如我数据迁移，应用迁移都完成了。但是数据迁移逻辑处理失败了。

**那这个事件应不应该保存呢？应该保存。**

**保存下来的时间能根据事件溯源吗？不能，因为它不是一个结束的事件。**

但是我们的数据迁移已经完成了，不会再进行二次迁移发送事件了，那这个事件怎么办呢？

我们可以对这个事件进行打标，发送从出去时为待处理，事件处理成功时修改状态为成功，事件处理失败时修改为失败。

这样我们在读库中取拉取业务事件进行溯源时就可以针对不同的状态进行不同的处理。

- **处理成功的事件：** 我们进行事件溯源，计算相应视图。
- **待处理的事件：** 我们进行事件溯源至最近的成功事件，计算相应的视图。
- **处理失败的事件：** 我们事件溯源至最近的成功事件，然后对处理失败的事件进行数据补偿处理，让数据最终变为成功状态。

## 四、总结

本文从MVC中前后端参数交互出发，对比通用DTO与CQRS模型在请求处理上的差异，知道了查询与命令的职责分离给系统维护带来的好处。

引入了事件溯源的模型去解决大数据环境下我们对于账单类型的可溯源数据的查询需求，并且分析事件溯源的优缺点。

最后我们串联了 CQRS、事件驱动模型、事件溯源模型这三块知识，讲解了如何在DDD中去使用它们，并对于我们实际在开发过程中可能出现的事件溯源问题做了分析与解答。

**结尾，我还是想从实际出发，建议你在使用DDD落地CQRS与事件驱动模型的过程中一定要区分好我们的业务场景。不是每个业务都需要事件溯源这样的功能，如果我们不需要它，完全可以仅发送事件，处理事件，读写同库。**
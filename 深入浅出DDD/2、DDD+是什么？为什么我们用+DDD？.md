# DDD 是什么？为什么我们用 DDD？

我相信基本上 99% 的 Java 开发读者，不管你是计科专业还是跨专业出身，初学 Spring 或 SpringBoot 进行 Web 开发的时候，接触到的代码分层都是 MVC 架构。

MVC，全称 Model View Control（模型-视图-控制器），其分层定义如下。

- **M（模型层/ DAO 层）** ：业务数据载体层。
- **V（视图层/ Controller 层）** ：展现给用户的数据表示层。
- **C（控制层/ Service 层）** ：接受 V（视图层）传递过来的请求进行业务逻辑处理，并将处理后的 M 层（模型层）数据返回给 V（视图层）。

因为 MVC 对于刚刚接触 Web 开发的同学来说有它自身独有的优势：

- 分层简单易懂；
- 层级逻辑替换方便；
- 可以降低层与层之间的依赖；
- 有利于标准化；
- 利于层与层逻辑的复用。

但真实情况是这样吗？**随着系统功能迭代，业务功能越来越丰富之后，控制层里面对于业务逻辑处理的代码也越来越多，维护成本也越来越高**。

举个例子：你负责了一个 MVC 项目从 0 到 1 的搭建，后面业务越来越好，招了新的研发一起迭代需求。在版本迭代的过程中，Service 层逻辑方法类似又不完全相同。A 同学拷贝了你的代码，改了一小段逻辑，开了一个新的方法。B 同学看到两个类似的逻辑，偷偷在里面加了一个 if/else 的判断。C 同学再按照自己的理解去写了一个已经存在的逻辑……

那么，随着时间的推移，你会遇到什么样的工程问题呢？

- 工程体积庞大；
- 需求迭代会出现明明是类似的功能，却无法复用代码逻辑的情况；
- 重复的代码很多；
- 大类（几千上万行）随处可见；
- 出了 Bug 不敢直接修复，只能继续往上贴逻辑；
- 代码可读性很差，不加注释你都难以理解业务逻辑；
- 功能之间耦合严重，改了一个 Bug，莫名其妙又出现了好几个其他的 Bug；
- 外部系统 RPC 接口修改，大范围影响到本系统的逻辑；
- ……

归根到底的原因是什么？

控制层就像个万能容器，什么代码都往里面写，承载了它这个年纪不该承受的业务逻辑。反观模型层与视图层，空空如也。业务逻辑不是跟着业务模型走的，而是在现有数据模型的情况下，或者先设计数据模型的情况下去迭代了业务需求。业务模块之间的边界被淡化，控制层内逻辑只要能实现需求，想怎么写就怎么写，没有一个规范与规约。

为了解决常规中大型 Web 系统 MVC 架构下存在的弊端问题，这就引出了 DDD。这也是本小册的大主题。在本小册中，我会带你看 DDD 如何从业务模型与业务边界出发去设计代码层级结构，将散落的、重复的逻辑内聚到业务模型中。从基础概念出发到落地实战演示，带你进入 DDD 的世界。

今天这一讲的内容相较而言偏原理些，都是讲解 DDD 相关的基础信息。虽然基础，但很关键，毕竟只有夯实好基础，而后才能更好地实战。

## 一、DDD 是什么

如果你在阅读小册前了解过 DDD ，应该听过网上那种官方的介绍：

- Domain Driven Design（领域驱动设计）；
- 六边形架构模型；
- 任何项目相关的人员都能理解的通用语言；
- ……

说的都多多少少抽象点了，“听君一席话，如听一席话”。下面我们化抽象为具体，结合示意图和业务示例来看看 DDD 到底是什么。

在使用 MVC 架构进行开发时，用户需求从被提出到落地，会经历下图的生命周期：

![image.png](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/1eeaf1af49fc4bf5974fa27f6fd7abb9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

可以看到，用户需求会被生命周期每层参与人理解转化。用户提出的 A 需求到了产品那里可能被理解成了 A1；需求评审结束后，进行编码开发需求之前，往往最先做的一步就是设计表结构，此时需求可能被理解成了 A2；等表结构设计完成，再“自底向上”设计 DAO、Service、Controller，最终产出了 A3。

**众所周知，“人”才是系统最大的 Bug。**

特别是研发需求在数据库结构这一层转化后，将业务以主观臆断行为进行了转化。一旦业务边界划分模糊，考虑不全，大量的逻辑补充堆积到了代码层实现，变得越来越难维护，到处是 if/else，“祖传代码”就此诞生了。

为了解决上述问题，DDD 所要做的就是（也可以结合下图来理解）：

- 通过**事件风暴**消除信息不对称，让业务相关人员都参与设计，确定每个业务领域的职责边界；

- 将常规 MVC 三层架构中自底 **（数据模型）** 向上的设计方式做一个**反转**，以业务为主导，自顶 **（业务模型）** 向下地进行业务领域划分；

- 将大的业务需求进行拆分，建立**业务领域模型**，分而治之。

![img](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/691975d95c174de29eefbaea6d961a6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

说到这里，对于 DDD 与 MVC 的区别，你可能还是有点模糊。这里我们就以`电商订单场景为例`分析下。假如我们现在要做一个电商下单的需求，这会涉及到用户选定商品、下订单、支付订单、订单发货等步骤。

- **MVC 架构。** 常见的做法是在分析好业务需求之后，就开始设计表结构了，订单表、支付表、商品表等。然后编写业务逻辑，但这仅仅是第一个版本的需求。不久后功能迭代了，订单支付后可以取消，下单的商品可以退换货，那是不是又需要进行加表？紧跟着对应的实现逻辑也需要修改？功能不断迭代，代码就不断地层层往上叠。

- **DDD 架构。** 首先进行业务边界划分，这里面核心是订单，那么**订单就是这个业务领域里面的聚合逻辑体现**。支付、商品信息、地址等都是围绕着订单展开。订单本身的属性确定之后，地址等信息只是一个属性的体现。当你将订单的领域模型构建好之后，后续的逻辑边界与表结构设计也就随之而来了，功能点无非就是对订单聚合内的业务逻辑编排组合罢了，让业务逻辑的实现最原子化。

## 二、DDD 如何解决 MVC 痛点

**业务的交互方式要分为两种：系统内部交互，系统与外部交互。**

MVC 分层下，不论是系统内交互还是系统与外部交互，逻辑都是按照功能点被杂糅在一起。Service 层利用 DO、DTO、VO 等业务 POJO 作为数据载体，完成了所有模型之间的逻辑处理、数据转换等跟业务有关或者无关的事情。Service 层臃肿且条理不清晰。就像是吃大乱炖，什么都往里面加，反正最后能吃就行。而这些 POJO 除了字段属性，内部没有任何的业务逻辑，这就是典型的**贫血模型**。

DDD 核心思想是什么呢？**解耦与内聚**！建立领域模型形成聚合根，将原先散落在 Service 层的业务逻辑收拢到领域模型内部，变成**充血模型**，聚合即为业务。业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有它们自己独立的做法。

下面来看看 DDD 是如何处理这两种交互方式的。

### 1. 系统内部交互

DDD 的价值观里面，**任何业务都是某个业务领域模型的职责体现**。为了完成某一个需求功能，将核心的业务逻辑定义在领域内部，应用服务层编排调用领域中的业务方法来实现功能点的需求。也就是说，业务功能是领域所供的能力的组合。

这样，**每个领域只会做自己业务边界内的事情，最小细粒度地去定义需求的实现**。原先模型层空空的贫血模型摇身一变，变成了充血模型。进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！

### 2. 系统与外部交互

假如微服务体系下，有一个下订单的需求。在通过**订单服务**下订单前，需要先请求**用户服务**获取下单用户的个人信息，如下图，用户服务在版本 A 时获取用户详情的接口是 interfaceA，版本 B 时换成 interfaceB。那么就会出现，需要修改订单服务中获取用户信息的逻辑。如果类似的逻辑散落在系统的很多地方，就会出现外部系统的业务逻辑变更，造成了本系统的大量依赖变更。

![img](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/f6514ecacb0145feb7caddc6898909c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

从上面的例子可知，系统内部完成业务逻辑可能会与外部系统进行交互，而此时外部系统一旦发生逻辑变更，将会影响到任意一个系统内依赖外部系统的逻辑。

为了解决这个痛点问题，DDD 通过定义**适配器**包装对外部系统的依赖。系统内部直接依赖适配器，由适配器去调用外部接口，减小外部系统的变动对本系统业务逻辑的影响。

![img](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-9/debbf26854ba4510b6780e2dcd7e4d0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

## 三、DDD 的优势是什么

通过上面的介绍和剖析，不难总结出 DDD 主要有以下优势。

- 从业务出发，自顶向下设计系统，优先考虑领域模型，而不是切割数据和行为，告别贫血模型；
- 领域设计简化复杂业务，内聚逻辑实现，准确传达业务规则，分而治之；
- 应用服务层的编排即展示了业务逻辑，增强了代码的可读性与可维护性；
- 消除业务参与人员的信息不对称，提升协助效率；
- 将外部系统等不可控因素转化为可控因素，减小系统间依赖；
- 适合于业务复杂的中台化的系统设计。

## 四、到底什么样的系统适配 DDD

看完上文对于 DDD 的分析之后，你是不是觉得一对比，MVC 简直就是“弟弟”？但是你回过头来想想，DDD 其实在十几年前就已经被提出来了，但为什么是近几年才开始逐渐进入大众的视野呢？总结起来，主要有以下几条原因。

- DDD 的结构不像 MVC 结构那么简单，分层更加复杂。
- 消除信息不对称的成本比较大，需要多方人员协作讨论业务模型。
- 迭代快的小系统不如直接使用 MVC 做好代码规范能够更快地上线。

**因此，不适配 DDD 的系统是什么呢？**

- 中小规模的系统，本身业务体量小，功能单一，选择 MVC 架构无疑是最好的。
- 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能（这种本身业务需求边界就不清晰，功能的可持续迭代性就很差，而且这种系统一般就是一口价买卖），这种也最好选择 MVC。

那相反地，适配 DDD 的系统是什么呢？**中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。**

总而言之就是：

- 你还不了解 DDD 或者你们系统功能简单，就选择 MVC；
- 你不知道选用什么技术架构做开发，处于业务探索阶段，选用 MVC；
- 其他时候就酌情考虑 DDD。

## 五、总结

这一讲我们以大多数 Java 开发工作者使用 MVC 过程中可能踩到的坑出发，对比分析介绍了 DDD 如何使用其核心思想来解决信息不对称、业务边界不清晰、祖传代码维护性差等问题，这样可以让你对 DDD 有一个粗略的认知，明白它与 MVC 架构的区别，以及它的主要优势在哪儿。

当然，DDD 绝对不是一个完美的应用架构，相比较 MVC 架构，它的理论概念与使用上要复杂很多。因此，如果你的系统不是一个中大型的、且可持续迭代的复杂业务系统，我还是建议使用 MVC 进行开发，利用好方法的抽象功能即可。

> ### Tips：
>
> > 有些概念错了。比如文中提到的传统三层架构下的POJO，应该是失血模型而不是贫血模型。实际上基于DDD思想的架构设计中，常常会用到贫血模型，所谓贫血模型，是对象有自己的属性和行为，但是不会与外部服务或者数据库直接产生依赖。
> > 实际上马丁福勒提出了：
> > 1.失血模型（entity就是个POJO）
> > 2.贫血模型（entity与dao层无关）
> > 3.充血模型（entity直接与dao层交互）
> > 3.胀血模型（取消service，只有entity和dao）
>
> > MVC和DDD之间还存在其它形式，不是说要么MVC，要么就必须DDD，合理规划service，就已经在划清领域边界了，但是如果只是停留在service的方法主要用来对传入的数据进行操作，则还只是面向过程编程，还需要找到领域事件，以及值对象来保证数据不可变，只有聚合根的领域事件才能改变数据或者状态，而不是传递DTO导致随处都可以对数据进行操作。


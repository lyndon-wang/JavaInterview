# 适配器模式

> **适配器模式**是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。是一种加中间层来解决问题的思想,为的是减少开发工作量,提高代码复用率.另外在对于第三方的服务中使用适配器层则可以很好的把自己系统与第三方依赖解耦,降低依赖.

## 从问题引入

假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。

![整合分析函数库之前的程序结构](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-8/202208071534830.png)

> 你无法 “直接” 使用分析函数库， 因为它所需的输入数据格式与你的程序不兼容。

你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。

##  解决方案

你可以创建一个*适配器*。 这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。

适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。 例如， 你可以使用一个将所有数据转换为英制单位 （如英尺和英里） 的适配器封装运行于米和千米单位制中的对象。

适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：

1. 适配器实现与其中一个现有对象兼容的接口。
2. 现有对象可以使用该接口安全地调用适配器方法。
3. 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。

有时你甚至可以创建一个双向适配器来实现双向转换调用。

![适配器解决方案](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-8/202208071541254.png)

让我们回到股票市场程序。 为了解决数据格式不兼容的问题， 你可以为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器， 然后让客户端仅通过这些适配器来与函数库进行交流。 当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。

## 真实世界类比

![适配器模式的示例](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-8/202208071542388.png)

> 出国旅行前后的旅行箱。

如果你是第一次从美国到欧洲旅行， 那么在给笔记本充电时可能会大吃一惊。 不同国家的电源插头和插座标准不同。 美国插头和德国插座不匹配。 同时提供美国标准插座和欧洲标准插头的电源适配器可以解决你的难题。

##  适配器模式结构

### 对象适配器

实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。

![image-20220807154427537](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-8/202208071544616.png)

---

### 类适配器

这一实现使用了继承机制： 适配器同时继承两个对象的接口。 请注意， 这种方式仅能在支持多重继承的编程语言中实现， 例如 C++。

![image-20220807154550795](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-8/202208071545865.png)

## 示例

### Java Set集合中的适配器

Java中的Set集合有者无序,唯一元素,查找复杂度O(1)等特性.这些特性Map数据结构的key是完全符合的,那么就可以利用适配器模式来完成Set的功能. 以`HashSet`为例,其内部持有的是一个值为固定Object的Map,如下图：

![img](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-8/202208071557706.png)

其所有的操作会通过`HashSet`这个适配器来操作`HashMap`这个被适配器.比如:

```javascript
public Iterator<E> iterator() {
        return map.keySet().iterator();
}
 public boolean add(E e) {
        return map.put(e, PRESENT)==null;
}
```

- Client：是调用方,也就是我们开发人员 
- Client Interface：是`Set`这个接口. 
- service：是`HashMap`,利用的是其功能. 
- Adapter：是`HashSet`.

## 适配器优缺点

![image-20220807154832818](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-8/202208071548875.png)
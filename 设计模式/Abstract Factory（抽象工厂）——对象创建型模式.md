# 抽象工厂

## 1.意图

提供一个接口一创建一系列相关或相互依赖的对象而无需指定他们具体的类。

## 2.动机

假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：

1. 一系列相关产品， 例如 `椅子`Chair 、  `沙发`Sofa和 `咖啡桌`Coffee­Table 。
2. 系列产品的不同变体。 例如， 你可以使用 `现代`Modern 、  `维多利亚`Victorian 、  `装饰风艺术`Art­Deco等风格生成 `椅子` 、  `沙发`和 `咖啡桌` 。

![image-20220302202917109](Abstract%20Factory%EF%BC%88%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.images/image-20220302202917109.png)

为了保证各个产品之间的可以执行，一个应用不应该为一个特定的外观或者风格进行硬编码，在整个应用中实例化特定的产品类型将使得后续难以进行修改。

## 3.解决方案

通过定义一个抽象的Factory类来解决这个问题，首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 `椅子`接口； 所有风格的咖啡桌都实现 `咖啡桌`接口， 以此类推。

接下来， 我们需要声明*抽象工厂*——包含系列中所有产品构造方法的接口。 例如 `create­Chair`创建椅子 、  `create­Sofa`创建沙发和 `create­Coffee­Table`创建咖啡桌 。 这些方法必须返回**抽象**产品类型， 即我们之前抽取的那些接口：  `椅子`， `沙发`和 `咖啡桌`等等。

那么该如何处理产品变体呢？ 对于系列产品的每个变体， 我们都将基于 `抽象工厂`接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如，  `现代家具工厂`Modern­Furniture­Factory只能创建 `现代椅子`Modern­Chair 、  `现代沙发`Modern­Sofa和 `现代咖啡桌`Modern­Coffee­Table对象。

![image-20220302203938157](Abstract%20Factory%EF%BC%88%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.images/image-20220302203938157.png)

客户仅通过抽象工厂接口创建产品，而不知道那些类实现了特定的产品。换言之，客户仅通过抽象类定义的接口交互，而不是用特定的具体类的接口。同时抽象工厂也增强了产品系列之间的依赖关系，一个维多利亚风格的咖啡桌应该与维多利亚风格的沙发，椅子一起使用，这一约束条件是作为使用维多利亚风格的具体工厂类的结果自动加上的。

最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。

## 4.适用性


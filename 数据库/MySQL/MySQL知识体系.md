# MySQL知识体系

## 1.数据类型

### 字段类型

#### 整型

`TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT` 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

INT(11) 中的数字**只是规定了交互工具显示字符的个数**，对于存储和计算来说是**没有意义**的。

#### 浮点数

`FLOAT` 和 `DOUBLE` 为浮点类型，`DECIMAL` 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 `DECIMAl` 类型的计算，因此 `DECIMAL` 的计算比浮点类型需要更高的代价。

`FLOAT`、`DOUBLE` 和 `DECIMAL` 都可以指定列宽，例如 `DECIMAL`(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

#### 字符串

主要有 `CHAR` 和 `VARCHAR` 两种类型，一种是定长的，一种是变长的。

`VARCHAR` 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

`VARCHAR` **会保留字符串末尾的空格，而 `CHAR` 会删除。**

#### 时间和日期

MySQL 提供了两种相似的日期时间类型: `DATETIME` 和 `TIMESTAMP`。

##### 1. DATETIME

能够保存从 1001 年到 9999 年的日期和时间，精度为**秒**，使用 **8 字节的存储空间**。

它与**时区无关**。

默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。

##### 2. TIMESTAMP

和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，**使用 4 个字节**，只能表示从 1970 年 到 2038 年。

它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

MySQL 提供了 `FROM_UNIXTIME`() 函数把 UNIX 时间戳转换为日期，并提供了 `UNIX_TIMESTAMP`() 函数把日期转换为 UNIX 时间戳。

默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。

**应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。**

### 选择优化的数据类型

- 更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少；
- 简单就好；例如，整形比字符串操作代价更低；使用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等；
- 尽量避免NULL；如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列

#### 字符串类型

> VARCHAR是最常见的字符串类型。VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。

下面这些情况使用VARCHAR是合适的：

1. 字符串的最大长度比平均长度大很多；
2. 列的更新很少，所以碎片不是问题；
3. 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。

当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。

CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片（行间碎片？）

> 使用VARCHAR(5)和VARCHAR(200)存储"hello"的空间开销是一样的。那么使用更短的列有什么优势吗？

事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。**所以最好的策略是只分配真正需要的空间。**

> BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。

与其他类型不同，MySQL把每个BLOB和TEXT值当做**一个独立的对象**去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。

#### 选择表示符（identifier）

**整数类型**通常是标识列的最佳选择，因为它们很快并且可以使用AUTO_INCREMENT。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。 对于完全随机的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：

- 因为插入值会随机的写入到索引的不同位置，所以使得INSERT语句更慢。这会导致叶分裂、磁盘随机访问。
- SELECT语句会变的更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。
- 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。

## 2.存储引擎

### InnoDB

是 MySQL 默认的事务型存储引擎，**只有在需要它不支持的特性时，才考虑使用其它存储引擎**。

实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

**不支持事务**。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 比较

- 事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键: InnoDB 支持外键。
- 备份: InnoDB 支持在线热备份。
- 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性: MyISAM 支持压缩表和空间数据索引。

## 3.索引

### B+ Tree 原理

> B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。
>
> B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。
>
> 在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

![image-20220708092547660](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207080925736.png)

**红黑树**等平衡树也可以用来实现索引，但是文件系统及数据库系统**普遍采用 B+ Tree** 作为索引结构，主要有以下两个原因:

**(一)更少的查找次数**

平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，**检索的次数**也就更多。

**(二)利用计算机预读特性**

为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。

操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，**相邻的节点也能够被预先载入**。

### MySQL 索引

索引是在**存储引擎层**实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

#### 1. B+Tree 索引

是**大多数 MySQL 存储引擎**的**默认索引**类型。

因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找**速度快很多**。除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。适用于**全键值、键值范围和键前缀查找**，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为**主索引**和**辅助索引**。

主索引的叶子节点 data 域记录着**完整的数据记录**，这种索引方式被称为**聚簇索引**。因为无法把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引。**

![image-20220708093218955](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207080932028.png)

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要**先查找到主键值，然后再到主索引中进行查找**。

![image-20220708093308704](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207080933774.png)

#### 2. 哈希索引

哈希索引能以 O(1) 时间进行查找，但是**失去了有序性**，它具有以下限制:

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“**自适应哈希索引**”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

#### 3. 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的**关键词**，而不是直接比较是否相等。查找条件使用 **MATCH AGAINST**，而不是普通的 WHERE。

全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

#### 4. 空间数据索引

MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从**所有维度来索引数据**，可以有效地使用任意维度来进行组合查询。

必须使用 **GIS** 相关的函数来维护数据

### 索引失效场景

[like百分号加前面一定不走索引吗？一不小心就翻车，关于mysql索引那些容易错的点](https://zhuanlan.zhihu.com/p/337778862)

[索引失效原理，终于有人讲明白了](https://cloud.tencent.com/developer/article/1704743)

不走索引的情况：

>**1**.没有查询条件，或者查询条件没有建立索引在业务数据库中，特别是数据量比较大的表。
>建议：
>
>> 换成有索引的列作为查询条件
>> 或者将查询频繁的列建立索引
>
>**2**.查询结果集是原表中的大部分数据，应该是25％以上
>查询的结果集，超过了总数行数25%，优化器觉得就没有必要走索引了。
>建议：
>
>> 如果业务允许，可以使用limit控制。
>> 结合业务判断，有没有更好的方式。如果没有更好的改写方案
>> 尽量不要在mysql存放这个数据了。放到redis里面。
>
>**3**.索引本身失效，统计数据不真实
>索引有自我维护的能力，对于表内容变化比较频繁的情况下，有可能会出现索引失效。
>更改方案：
>
>> 备份表数据，删除重建相关表。
>
>**4**.查询条件使用函数在索引列上，或者对索引列进行运算，运算包括(+，-，*，/，! 等)
>
>```mysql
>SELECT `sname` FROM `t_stu` WHERE `age`=20;       -- 会使用索引
>SELECT `sname` FROM `t_stu` WHERE `age`+10=30;    -- 不会使用索引！！因为所有索引列参与了计算
>SELECT `sname` FROM `t_stu` WHERE `age`=30-10;    -- 会使用索引
>SELECT `sname` FROM `stu` WHERE concat(`sname`,'abc') ='Jaskeyabc';   -- 不会使用索引,因为使用了函数运算,原理与上面相同
>SELECT `sname` FROM `stu` WHERE `sname`=concat('Jaskey','abc');      -- 会使用索引
>```
>
>更改方法：
>
>> 减少在mysql中使用加减乘除等计算运算。
>
>**5**.**隐式转换导致索引失效**。这一点应当引起重视.也是开发中经常会犯的错误.
>索引建立的字段为varchar();
>select * from stu where name = ‘111’；走索引
>select * from stu where name = 111；不走索引
>
>这是一个坑，假设有一张表,里面的a列是一个字符char类型,且a上建立了索引,你用它与数字类型做比较判断的话：
>```mysql
>CREATE TABLE `t1` (`a` char(10));
>SELECT * FROM `t1` WHERE `a`='1' -- 走索引
>SELECT * FROM `t2` WHERE `a`=1 -- 字符串和数字比较，不走索引！
>```
>但是如果那个表那个列是一个数字类型，拿来和字符类型的做比较，则不会影响到使用索引
>
>```mysql
>CREATE TABLE `t2` (`b` int);
>SELECT * FROM `t2` WHERE `b`='1' -- 虽然b是数字类型，和'1'比较依然走索引
>```
>
>但是，无论如何，这种额外的隐式类型转换都是开销，而且由于有字符和数字比就不走索引的情况，**故建议避免一切隐式类型转换**
>
>更改方法：
>
>> 与研发协商，语句查询符合规范。
>
>**6**.<> ，not in 不走索引（辅助索引）
>
>更改方法：
>尽量不要用以上方式进行查询，或者选择有索引列为筛选条件。
>单独的>,<,in 有可能走，也有可能不走，和结果集有关，尽量结合业务添加limit
>or或in 尽量改成union
>
>**7**.like “%” 百分号在最前面不走
>
>EXPLAIN SELECT * FROM teltab WHERE telnum LIKE ‘31%’ 走索引
>EXPLAIN SELECT * FROM teltab WHERE telnum LIKE ‘%110’ 不走索引
>更改方法：
>
>> %linux%类的搜索需求，可以使用elasticsearch+mongodb 专门做搜索服务的数据库产品
>
>**8.**尽量避免 OR 操作
>
>```mysql
>select * from dept where dname='jaskey' or loc='bj' or deptno=45 
>-- 如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引
>```
>
>所以除非每个列都建立了索引，否则不建议使用OR，在多列OR中，可以考虑用UNION 替换

### 索引下推

[索引下推，这个点你肯定不知道！](https://www.51cto.com/article/679792.html)

### 索引优化

#### 1. 独立的列

在进行查询时，索引列**不能是表达式的一部分**，也**不能是函数的参数**，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引:

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 
```

#### 2. 多列索引

在需要使用多个列作为条件进行查询时，使用**多列索引**比使用**多个单列索**引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

#### 3. 索引列的顺序

让**选择性最强的索引**列放在前面，索引的**选择性**是指: **不重复的索引值和记录总数的比值**。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

```html
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

#### 4. 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

对于前缀长度的选取需要根据索引选择性来确定。

#### 5. 覆盖索引

**索引包含所有需要查询的字段的值。**

具有以下优点:

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎(例如 MyISAM)在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用(通常比较费时)。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引

#### 6.filesort

[MySQL Order By实现原理分析和Filesort优化](https://blog.csdn.net/hguisu/article/details/7161981)

filesort是通过相应的排序算法将取得的数据在内存中进行排序，所使用的内存区域也就是通过`sort_buffer_size` 系统变量所设置的排序区。这个排序区是每个`Thread` 独享的，可能同一时刻在MySQL 中存在多个 sort buffer 内存区域。
MySQL中`filesort` 的**实现算法**有两种：

1. 双路排序：首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行指针信息，然后在sort buffer 中进行排序。排完序后再根据行指针信息回表拿全部信息
2. 单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序。

MySQL主要通过比较所设定的系统参数 `max_length_for_sort_data`的大小和Query 语句所取出的字段类型大小总和来判定需要使用哪一种排序算法。如果 `max_length_for_sort_data`更大，则使用第二种优化后的算法，反之使用第一种算法。

> using filesort**不一定引起mysql的性能问题**。但是如果查询次数非常多，每次在mysql中进行排序，**还是会有影响的**。

**优化filesort方法：**

当无法避免排序操作时，很显然应该尽可能让 MySQL 选择使用第二种单路算法来进行排序。这样可以减少大量的随机IO操作，很大幅度地提高排序工作的效率。

1. 加大 `max_length_for_sort_data` 参数的设置

   >当所有返回字段的最大长度小于这个参数值时，MySQL 就会选择改进后的单路排序，反之，则选择老式的双路排序。所以，如果有充足的内存让MySQL 存放须要返回的非排序字段，就可以加大这个参数的值来让 MySQL 选择使用改进版的排序算法。

2. 去掉不必要的返回字段

   >当内存不是很充裕时，不能简单地通过强行加大上面的参数来强迫 MySQL 去使用改进版的排序算法，否则可能会造成 MySQL 不得不将数据分成很多段，然后进行排序，这样可能会得不偿失。此时就须要去掉不必要的返回字段，让返回结果长度适应 max_length_for_sort_data 参数的限制。

3. 增大 sort_buffer_size 参数设置

   >增大 sort_buffer_size 并不是为了让 MySQL选择改进版的排序算法，而是为了让MySQL尽量减少在排序过程中对需要排序的数据进行分段，因为分段会造成 MySQL 使用临时表来进行交换排序。

### 索引的优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，也就不需要创建临时表(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)。
- 将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的，也就将相邻的数据都存储在一起)。

### 索引的使用场景

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。
- 对于中到大型的表，索引就非常有效。
- 但是对于**特大型的表**，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## 4.性能优化

### 使用 Explain 进行分析

Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

比较**重要的字段**有:

- select_type : 查询类型，有简单查询、联合查询、子查询等
- key : 使用的索引
- rows : 扫描的行数

###  优化数据访问

#### 1. 减少请求的数据量

- 只返回必要的列: 最好不要使用 SELECT * 语句。
- 只返回必要的行: 使用 LIMIT 语句来限制返回的数据。
- 缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

#### 2. 减少服务器端扫描的行数

最有效的方式是使用索引来覆盖查询。

### 重构查询方式

#### 1. 切分大查询

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

```sql
DELEFT FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
```

```sql
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
} while rows_affected > 0
```

#### 2. 分解大连接查询

将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:

- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
- 减少锁竞争；
- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
- 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

```sql
SELECT * FROM tab
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
```

```sql
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
  
```

## 5.分表分库

### 水平切分

水平切分又称为 Sharding，它是将**同一个表中的记录拆分到多个结构相同的表中。**

当一个表的数据不断增多时，Sharding 是必然的选择，它可以**将数据分布到集群的不同节点**上，从而**缓存单个数据库的压力**。

### 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的**关系密集程度**进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

###  Sharding 策略

- 哈希取模: hash(key) % NUM_DB
- 范围: 可以是 ID 范围也可以是时间范围
- 映射表: 使用单独的一个数据库来存储映射关系

### Sharding 存在的问题及解决方案

#### 1. 事务问题

使用分布式事务来解决，比如 XA 接口。

#### 2. 链接

可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。

#### 3. ID 唯一性

- 使用全局唯一 ID: GUID
- 为每个分片指定一个 ID 范围
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)

## 6.主从复制与读写分离

### 主从复制

主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** : 负责将主服务器上的数据更改写入二进制日志中。
- **I/O 线程** : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。
- **SQL 线程** : 负责读取中继日志并重放其中的 SQL 语句。

![image-20220708101213644](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207081012709.png)

### 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而**从服务器处理读操作**。

读写分离能提高性能的原因在于:

- 主从服务器负责各自的读和写，极大程度**缓解了锁的争用**；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用**代理方式**来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![image-20220708101341821](https://typora-imagehost-1308499275.cos.ap-shanghai.myqcloud.com/2022-7/202207081013881.png)

## 7.[MySQL InnoDB的MVCC实现机制](https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html)

**！！MVCC解决不可重复读实现原理分析-->[深入理解MySQL底层事务隔离级别的实现原理](https://cloud.tencent.com/developer/article/1892952)**